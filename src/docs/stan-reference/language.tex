\part{Stan Modeling Language}


\chapter{Data Types and Variable Declarations}\label{data-types.chapter}

\noindent
This chapter covers the data types for expressions in Stan.  Every
variable used in a Stan program must have a declared data type.  Only
values of that type will be assignable to the variable (except for
temporary states of transformed data and transformed parameter
values).  This follows the convention of programming languages like
\Cpp, not the conventions of scripting languages like Python or
statistical languages such as \R or \BUGS.

The motivation for strong, static typing is threefold.
%
\begin{itemize}
\item Strong typing forces the programmer's intent to be declared with
  the variable, making programs easier to comprehend and hence easier
  to debug and maintain.
\item Strong typing allows programming errors relative to the declared
  intent to be caught sooner (at compile time) rather than later (at
  run time).  The Stan compiler (called through an interface such as
  CmdStan, RStan, or PyStan) will flag any type errors and indicate
  the offending expressions quickly when the program is compiled.
\item Constrained types will catch runtime data, initialization, and
  intermediate value errors as soon as they occur rather than allowing
  them to propagate and potentially pollute final results.
\end{itemize}
%
Strong typing disallows assigning the same variable to objects of
different types at different points in the program or in different
invocations of the program.

\section{Overview of Data Types}

%%%
Arguments for built-in and user-defined functions and local variables
are required to be basic data types, meaning an unconstrained
primitive, vector, or matrix type or an array of such.

Passing arguments to functions in Stan works just like assignment to
basic types.  Stan functions are only specified for the basic data
types of their arguments, including array dimensionality, but not for
sizes or constraints.  Of course, functions often check constraints as
part of their behavior.  

\subsection{Primitive Types}

Stan provides two primitive data types, \code{real} for continuous
values and \code{int} for integer values.

\subsection{Vector and Matrix Types}
Stan provides three matrix-based data types, \code{vector} for column
vectors, \code{row\_vector} for row vectors, and \code{matrix} for
matrices.

\subsection{Array Types}

Any type (including the constrained types discussed in the next
section) can be made into an array type by declaring array arguments.
For example,
%
\begin{stancode}
real x[10];
matrix[3, 3] m[6, 7];
\end{stancode}
%
declares \code{x} to be a one-dimensional array of size 10 containing
real values, and declares \code{m} to be a two-dimensional array of
size $6 \times 7$ containing values that are $3 \times 3$ matrices.

% \subsection{Basic Data Types}

% The primitive Stan data types are \code{real} for continuous scalar
% quantities and \code{int} for integer values.  The compound data
% types include \code{vector} (of real values), \code{row\_vector} (of
% real values), and \code{matrix} (of real values).

\subsection{Constrained Data Types}

Declarations of variables other than local variables may be provided
with constraints.  These constraints are not part of the underlying
data type for a variable, but determine error checking in the
transformed data, transformed parameter, and generated quantities
block, and the transform from unconstrained to constrained space in
the parameters block.

All of the basic data types may be given lower and upper bounds using
syntax such as
%
\begin{stancode}
int<lower = 1> N;
real<upper = 0> log_p;
vector<lower = -1, upper = 1>[3] rho;
\end{stancode}

There are also special data types for structured vectors and
matrices.
% There are four constrained vector data types, \code{simplex}
% for unit simplexes, \code{unit\_vector} for unit-length vectors,
% \code{ordered} for ordered vectors of scalars and
% \code{positive\_ordered} for vectors of positive ordered
% scalars. There are specialized matrix data types \code{corr\_matrix}
% and \code{cov\_matrix} for correlation matrices (symmetric, positive
% definite, unit diagonal) and covariance matrices (symmetric, positive
% definite).  The type \code{cholesky\_factor\_cov} is for Cholesky
% factors of covariance matrices (lower triangular, positive diagonal,
% product with own transpose is a covariance matrix).  The type
% \code{cholesky\_factor\_corr} is for Cholesky factors of correlation
% matrices (lower triangular, positive diagonal, unit-length rows).

Constraints provide error checking for variables defined in the \code{data},
\code{transformed data}, \code{transformed parameters}, and 
\code{generated quantities} blocks.
%
Constraints are critical for variables declared in the
\code{parameters} block, where they determine the transformation from
constrained variables (those satisfying the declared constraint) to
unconstrained variables (those ranging over all of $\mathbb{R}^n$).

It is worth calling out the most important aspect of constrained data
types: 
%
\begin{quote}
\it
The model must have support (non-zero density) at every value of the
parameters that meets their declared constraints.
\end{quote}
%
If the declared parameter constraints are less strict than the
support, the samplers and optimizers may have any of a number of
pathologies including just getting stuck, failure to initialize,
excessive Metropolis rejection, or biased samples due to inability to
explore the tails of the distribution.

% Integer or real types may be constrained with lower bounds, upper
% bounds, or both.  There are four constrained vector data types,
% \code{simplex} for unit simplexes, \code{unit\_vector} for unit-length
% vectors, \code{ordered} for ordered vectors of scalars and
% \code{positive\_ordered} for vectors of positive ordered scalars.
% There are specialized matrix data types \code{corr\_matrix} and
% \code{cov\_matrix} for correlation matrices (symmetric, positive
% definite, unit diagonal) and covariance matrices (symmetric, positive
% definite).  The type \code{cholesky\_factor\_cov} is for Cholesky
% factors of covariance matrices (lower triangular, positive diagonal,
% product with own transpose is a covariance matrix).  The type
% \code{cholesky\_factor\_corr} is for Cholesky factors of correlation
% matrices (lower triangular, positive diagonal, unit-length rows).

% \subsection{Arrays}

% Stan supports arrays of arbitrary order of any of the basic data
% types or constrained basic data types.  This includes
% three-dimensional arrays of integers, one-dimensional arrays of
% positive reals, four-dimensional arrays of simplexes, one-dimensional
% arrays of row vectors, and so on.

\section{Primitive Numerical Data Types}\label{numerical-data-types.section}

Unfortunately, the lovely mathematical abstraction of integers and
real numbers is only partially supported by finite-precision computer
arithmetic.

\subsection{Integers}

Stan uses 32-bit (4-byte) integers for all of its integer
representations.  The maximum value that can be represented
as an integer is $2^{31}-1$; the minimum value is $-(2^{31})$.

When integers overflow, their values wrap.  Thus it is up to the Stan
programmer to make sure the integer values in their programs stay in
range.  In particular, every intermediate expression must have an
integer value that is in range.

Integer arithmetic works in the expected way for addition,
subtraction, and multiplication, but rounds the result of division
(see \refsection{int-arithmetic} for more information).

\subsection{Reals}

Stan uses 64-bit (8-byte) floating point representations of real
numbers.  Stan roughly%
%
\footnote{Stan compiles integers to \code{int} and reals to
  \code{double} types in \Cpp.  Precise details of rounding will depend
  on the compiler and hardware architecture on which the code is run.}
%
follows the IEEE 754 standard for floating-point computation.
The range of a 64-bit number is roughly $\pm 2^{1022}$, which is
slightly larger than $\pm 10^{307}$.  It is a good idea to stay well
away from such extreme values in Stan models as they are prone to
cause overflow.

64-bit floating point representations have roughly 15 decimal digits
of accuracy.  But when they are combined, the result often has less
accuracy.  In some cases, the difference in accuracy between two
operands and their result is large.

There are three special real values used to represent (1) not-a-number
value for error conditions, (2) positive infinity for overflow, and
(3) negative infinity for overflow.  The behavior of these special
numbers follows standard IEEE 754 behavior.  

\subsubsection{Not-a-number}

The not-a-number value propagates.  If an argument to a real-valued
function is not-a-number, it either rejects (an exception in the
underlying C++) or returns not-a-number itself.  For boolean-valued
comparison operators, if one of the arguments is not-a-number, the
return value is always zero (i.e., false).

\subsubsection{Infinite values}

Positive infinity is greater than all numbers other than itself and
not-a-number; negative infinity is similarly smaller.  Adding an
infinite value to a finite value returns the infinite value.  Dividing
a finite number by an infinite value returns zero; dividing an
infinite number by a finite number returns the infinite number of
appropriate sign.  Dividing a finite number by zero returns positive
infinity. Dividing two infinite numbers produces a not-a-number value
as does subtracting two infinite numbers.  Some functions are
sensitive to infinite values; for example, the exponential function
returns zero if given negative infinity and positive infinity if given
positive infinity.  Often the gradients will break down when values
are infinite, making these boundary conditions less useful than they
may appear at first.


\subsection{Promoting Integers to Reals}

Stan automatically promotes integer values to real values if
necessary, but does not automatically demote real values to integers.
For very large integers, this will cause a rounding error to fewer
significant digits in the floating point representation than in the
integer representation.

Unlike in \Cpp, real values are never demoted to integers.  Therefore,
real values may only be assigned to real variables.  Integer values
may be assigned to either integer variables or real variables.
Internally, the integer representation is cast to a floating-point
representation.  This operation is not without overhead and should
thus be avoided where possible.


\section{Univariate Data Types and Variable Declarations}

All variables used in a Stan program must have an explicitly declared
data type.  The form of a declaration includes the type and the name
of a variable.  This section covers univariate types, the next section
vector and matrix types, and the following section array types.

\subsection{Unconstrained Integer}

Unconstrained integers are declared using the \code{int} keyword.
For example, the variable \code{N} is declared to be an integer as follows.
%
\begin{stancode}
int N;
\end{stancode}
%

\subsection{Constrained Integer}

Integer data types may be constrained to allow values only in a
specified interval by providing a lower bound, an upper bound, or
both.  For instance, to declare \code{N} to be a positive integer, use
the following.
%
\begin{stancode}
int<lower=1> N;
\end{stancode}
%
This illustrates that the bounds are inclusive for integers.

To declare an integer variable \code{cond} to take only binary values,
that is zero or one, a lower and upper bound must be provided, as in
the following example.
%
\begin{stancode}
int<lower=0,upper=1> cond;
\end{stancode}


\subsection{Unconstrained Real}

Unconstrained real variables are declared using the keyword
\code{real}, The following example declares \code{theta} to be an
unconstrained continuous value.
%
\begin{stancode}
real theta;
\end{stancode}
%

\subsection{Constrained Real}

Real variables may be bounded using the same syntax as integers.  In
theory (that is, with arbitrary-precision arithmetic), the bounds on
real values would be exclusive.  Unfortunately, finite-precision
arithmetic rounding errors will often lead to values on the
boundaries, so they are allowed in Stan.

The variable \code{sigma} may be declared to be non-negative as follows.
%
\begin{stancode}
real<lower=0> sigma;
\end{stancode}
%
The following declares the variable \code{x} to be less than or equal
to $-1$.
%
\begin{stancode}
real<upper=-1> x;
\end{stancode}
%
To ensure \code{rho} takes on values between $-1$ and $1$, use the
following declaration.
%
\begin{stancode}
real<lower=-1,upper=1> rho;
\end{stancode}
%

\subsubsection{Infinite Constraints}

Lower bounds that are negative infinity or upper bounds that are
positive infinity are ignored.  Stan provides constants
\code{positive\_infinity()} and \code{negative\_infinity()} which may
be used for this purpose, or they may be read as data in the dump
format.


\subsection{Expressions as Bounds}

Bounds for integer or real variables may be arbitrary expressions.
The only requirement is that they only include variables that have
been defined before the declaration.  If the bounds themselves are
parameters, the behind-the-scenes variable transform accounts for them
in the log Jacobian.

For example, it is acceptable to have the
following declarations.
%
\begin{stancode}
data {
 real lb;
}
parameters {
   real<lower=lb> phi;
}
\end{stancode}
%
This declares a real-valued parameter \code{phi} to take values
greater than the value of the real-valued data variable \code{lb}.
Constraints may be complex expressions, but must be of type \code{int}
for integer variables and of type \code{real} for real variables
(including constraints on vectors, row vectors, and matrices).
Variables used in constraints can be any variable that has been
defined at the point the constraint is used.  For instance,
\begin{stancode}
data {
   int<lower=1> N;
   real y[N];
}
parameters {
   real<lower=min(y), upper=max(y)> phi;
}
\end{stancode}
%
This declares a positive integer data variable \code{N}, an array
\code{y} of real-valued data of length \code{N}, and then a parameter
ranging between the minimum and maximum value of \code{y}.  As shown
in the example code, the functions \code{min()} and \code{max()} may
be applied to containers such as arrays.

\section{Vector and Matrix Data Types}

Stan provides three types of container objects: arrays, vectors, and
matrices. Vectors and matrices are more limited kinds of data
structures than arrays.  Vectors are intrinsically one-dimensional
collections of reals, whereas matrices are intrinsically two
dimensional.  Vectors, matrices, and arrays are not assignable to one
another, even if their dimensions are identical.  A $3 \times 4$
matrix is a different kind of object in Stan than a $3 \times 4$
array.

The intention of using matrix types is to call out their usage in the
code.  There are three situations in Stan where {\it only} vectors and
matrices may be used,
%
\begin{itemize}
\item matrix arithmetic operations (e.g., matrix multiplication)
\item linear algebra functions (e.g., eigenvalues and determinants),
  and
\item multivariate function parameters and outcomes (e.g.,
  multivariate normal distribution arguments).
\end{itemize}
%

Vectors and matrices cannot be typed to return integer values.  They
are restricted to \code{real} values.%
%
\footnote{This may change if Stan is called upon to do complicated
  integer matrix operations or boolean matrix operations.  Integers
  are not appropriate inputs for linear algebra functions.}

% \subsection{Values}

% Vectors, row vectors, and matrices contain real values.  Arrays, on
% the other hand, may contain any kind of value, including integers and
% structured values like vectors.

% Arrays cannot be assigned to vectors and vice-versa.  Similarly,
% vectors cannot be assigned to matrices and vice-versa, even if their
% dimensions conform.

\subsection{Indexing from 1}

Vectors and matrices, as well as arrays, are indexed starting from one
in Stan.  This follows the convention in statistics and linear
algebra as well as their implementations in the statistical software
packages \R, \MATLAB, \BUGS, and \JAGS.  General computer programming
languages, on the other hand, such as \Cpp and Python, index arrays
starting from zero.

\subsection{Vectors}

Vectors in Stan are column vectors; see the next subsection for
information on row vectors.  Vectors are declared with a size (i.e., a
dimensionality).  For example, a 3-dimensional vector is declared with
the keyword \code{vector}, as follows.
%
\begin{stancode}
vector[3] u;
\end{stancode}
%
Vectors may also be declared with constraints, as in the following
declaration of a 3-vector of non-negative values.
%
\begin{stancode}
vector<lower=0>[3] u;
\end{stancode}
%

\subsection{Unit Simplexes}

A unit simplex is a vector with non-negative values whose entries sum
to 1.  For instance, $(0.2,0.3,0.4,0.1)^{\top}$ is a unit 4-simplex.
Unit simplexes are most often used as parameters in categorical
or multinomial distributions, and they are also the sampled variate in
a Dirichlet distribution.  Simplexes are declared with their full
dimensionality.  For instance, \code{theta} is declared to
be a unit $5$-simplex by
%
\begin{stancode}
simplex[5] theta;
\end{stancode}
%

Unit simplexes are implemented as vectors and may be assigned to other
vectors and vice-versa.  Simplex variables, like other constrained
variables, are validated to ensure they contain simplex values; for
simplexes, this is only done up to a statically specified accuracy
threshold $\epsilon$ to account for errors arising from floating-point
imprecision.

\subsection{Unit Vectors}

A unit vector is a vector with a norm of one.  For instance,
$(0.5,0.5,0.5,0.5)^{\top}$ is a unit 4-vector.
Unit vectors are sometimes used in directional statistics.
Unit vectors are declared with their full
dimensionality.  For instance, \code{theta} is declared to
be a unit $5$-vector by
%
\begin{stancode}
unit_vector[5] theta;
\end{stancode}
%
Unit vectors are implemented as vectors and may be assigned to other
vectors and vice-versa.  Unit vector variables, like other constrained
variables, are validated to ensure that they are indeed unit length; for
unit vectors, this is only done up to a statically specified accuracy
threshold $\epsilon$ to account for errors arising from floating-point
imprecision.

\subsection{Ordered Vectors}

An ordered vector type in Stan represents a vector whose entries are
sorted in ascending order.  For instance, $(-1.3,2.7,2.71)^{\top}$ is
an ordered 3-vector.  Ordered vectors are most often employed as cut
points in ordered logistic regression models (see
\refsection{ordered-logistic}).

The variable \code{c} is declared as an ordered 5-vector by
%
\begin{stancode}
ordered[5] c;
\end{stancode}
%
After their declaration, ordered vectors, like unit simplexes, may be
assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.


\subsection{Positive, Ordered Vectors}

There is also a positive, ordered vector type which operates similarly
to ordered vectors, but all entries are constrained to be positive.
For instance, $(2,3.7,4,12.9)$ is a positive, ordered 4-vector.

The variable \code{d} is declared as a positive, ordered 5-vector by
%
\begin{stancode}
positive_ordered[5] d;
\end{stancode}
%
Like ordered vectors, after their declaration positive ordered vectors
assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.

\subsection{Row Vectors}

Row vectors are declared with the keyword \code{row\_vector}.
Like (column) vectors, they are declared with a size.  For example,
a 1093-dimensional row vector \code{u} would be declared as
%
\begin{stancode}
row_vector[1093] u;
\end{stancode}
%
Constraints are declared as for vectors, as in the following example
of a 10-vector with values between -1 and 1.
\begin{stancode}
row_vector<lower=-1,upper=1>[10] u;
\end{stancode}
%

Row vectors may not be assigned to column vectors, nor may column
vectors be assigned to row vectors.  If assignments are required, they
may be accommodated through the transposition operator.

\subsection{Matrices}

Matrices are declared with the keyword \code{matrix} along with a
number of rows and number of columns.  For example,
%
\begin{stancode}
matrix[3, 3] A;
matrix[M, N] B;
\end{stancode}
%
declares \code{A} to be a $3 \times 3$ matrix and \code{B} to be a $M
\times N$ matrix.  For the second declaration to be well formed, the
variables \code{M} and \code{N} must be declared as integers in either
the data or transformed data block and before the matrix declaration.

Matrices may also be declared with constraints, as in this ($3 \times $4)
matrix of non-positive values.
%
\begin{stancode}
matrix<upper=0>[3, 4] B;
\end{stancode}
%

\subsubsection{Assigning to Rows of a Matrix}

Rows of a matrix can be assigned by indexing the left-hand side of an
assignment statement. For example, this is possible.
%
\begin{stancode}
matrix[M, N] a;
row_vector[N] b;
// ...
a[1] = b;
\end{stancode}
%
This copies the values from row vector \code{b} to \code{a[1]}, which
is the first row of the matrix \code{a}.  If the number of columns in
\code{a} is not the same as the size of \code{b}, a run-time error is
raised;  the number of rows of \code{a} is \code{N}, which is also the
size of \code{b}.

Assignment works by copying values in Stan.  That means any subsequent
assignment to \code{a[1]} does not affect \code{b}, nor does an
assignment to \code{b} affect \code{a}.


\subsection{Correlation Matrices}

Matrix variables may be constrained to represent correlation matrices.
A matrix is a correlation matrix if it is symmetric and positive
definite, has entries between $-1$ and $1$, and has a unit diagonal.
Because correlation matrices are square, only one dimension needs
to be declared.  For example,
%
\begin{stancode}
corr_matrix[3] Sigma;
\end{stancode}
%
declares \code{Sigma} to be a $3 \times 3$ correlation matrix.

Correlation matrices may be assigned to other matrices, including
unconstrained matrices, if their dimensions match, and vice-versa.

\subsection{Cholesky Factors of Correlation Matrices}

Matrix variables may be constrained to represent the Cholesky factors
of a correlation matrix.

A Cholesky factor for a correlation matrix $L$ is a $K \times K$
lower-triangular matrix with positive diagonal entries and rows that
are of length 1 (i.e., $\sum_{n=1}^K L_{m,n}^2 = 1$).  If $L$ is a
Cholesky factor for a correlation matrix, then $L\,L^{\top}$ is a
correlation matrix (i.e., symmetric postive definite with a unit
diagonal).

A declaration such as
follows.
%
\begin{stancode}
cholesky_factor_corr[K] L;
\end{stancode}
%
declares \code{L} to be a Cholesky factor for a \code{K} by \code{K}
correlation matrix.

\subsection{Covariance Matrices}

Matrix variables may be constrained to represent covariance matrices.
A matrix is a covariance matrix if it is symmetric and positive
definite.  Like correlation matrices, covariance matrices only need a
single dimension in their declaration.  For instance,
%
\begin{stancode}
cov_matrix[K] Omega;
\end{stancode}
%
declares \code{Omega} to be a $K \times K$ covariance matrix, where
$K$ is the value of the data variable \code{K}.

\subsection{Cholesky Factors of Covariance Matrices}

Matrix variables may be constrained to represent the Cholesky factors
of a covariance matrix.  This is often more convenient or more
efficient than representing covariance matrices directly.

A Cholesky factor $L$ is an $M \times N$ lower-triangular matrix (if
$m < n$ then $L[m, n] =0$) with a strictly positive diagonal ($L[k, k]
> 0$) and $M \geq N$.  If $L$ is a Cholesky factor, then $\Sigma = L
\, L^{\top}$ is a covariance matrix.  Furthermore, every covariance
matrix has a Cholesky factorization.

The typical case of a square Cholesky factor may be declared with a
single dimension,
%
\begin{stancode}
cholesky_factor_cov[4] L;
\end{stancode}
%
In general, two dimensions may be declared, with the above being equal to
\code{cholesky\_factor\_cov[4,~4]}.  The
type \code{cholesky\_factor\_cov[M,~N]} may be used for the general
$M \times N$.

\subsection{Assigning Constrained Variables}

Constrained variables of all types may be assigned to other variables
of the same unconstrained type and vice-versa.  Matching is interpreted strictly
as having the same basic type and number of array dimensions.
Constraints are not considered, but basic data types are. For instance, a
variable declared to be \code{real<lower=0,upper=1>} could be assigned
to a variable declared as \code{real} and vice-versa.  Similarly, a
variable declared as \code{matrix[3,~3]} may be assigned to a variable
declared as \code{cov\_matrix[3]} or
\code{cholesky\_factor\_cov[3]}, and vice-versa.

Checks are carried out at the end of each relevant block of statements
to ensure constraints are enforced.  This includes run-time size
checks.  The Stan compiler isn't able to catch the fact that an
attempt may be made to assign a matrix of one dimensionality to a
matrix of mismatching dimensionality.


\subsection{Expressions as Size Declarations}

Variables may be declared with sizes given by expressions.  Such
expressions are constrained to only contain data or transformed data
variables.  This ensures that all sizes are determined once the data
is read in and transformed data variables defined by their statements.
For example, the following is legal.
%
\begin{stancode}
data {
  int<lower=0> N_observed;    int<lower=0> N_missing;
  // ...
transformed parameters {
  vector[N_observed + N_missing] y;
  // ...
\end{stancode}

\subsection{Accessing Vector and Matrix Elements}

If \code{v} is a column vector or row vector, then \code{v[2]} is the
second element in the vector.  If \code{m} is a matrix, then
\code{m[2,~3]} is the value in the second row and third column.

Providing a matrix with a single index returns the specified row.  For
instance, if \code{m} is a matrix, then \code{m[2]} is the second row.
This allows Stan blocks such as
%
\begin{stancode}
matrix[M, N] m;
row_vector[N] v;
real x;
// ...
v = m[2];
x = v[3];   // x == m[2][3] == m[2, 3]
\end{stancode}
%
The type of \code{m[2]} is \code{row\_vector} because it is the second
row of \code{m}.  Thus it is possible to write \code{m[2][3]} instead
of \code{m[2,~3]} to access the third element in the second row.  When
given a choice, the form \code{m[2,~3]} is preferred.%
%
\footnote{As of Stan version 1.0, the form
  \code{m[2,~3]} is more efficient because it does not require the
  creation and use of an intermediate expression template for
  \code{m[2]}.  In later versions, explicit calls to \code{m[2][3]}
  may be optimized to be as efficient as \code{m[2,~3]} by the Stan
  compiler.\label{array-index-style.footnote}}


\subsection{Size Declaration Restrictions}

An integer expression is used to pick out the sizes of vectors,
matrices, and arrays.  For instance, we can declare a vector of size
\code{M + N} using
%
\begin{stancode}
vector[M + N] y;
\end{stancode}
%
Any integer-denoting expression may be used for the size declaration,
providing all variables involved are either data, transformed data, or
local variables.  That is, expressions used for size declarations may
not include parameters or transformed parameters or generated
quantities.

\section{Array Data Types}\label{array-data-types.section}

Stan supports arrays of arbitrary dimension.  The values in an array
can be any type, so that arrays may contain values that are simple
reals or integers, vectors, matrices, or other arrays.  Arrays are the
only way to store sequences of integers, and some functions in Stan,
such as discrete distributions, require integer arguments.

A two-dimensional array is just an array of arrays, both conceptually
and in terms of current implementation.  When an index is supplied to
an array, it returns the value at that index.  When more than one
index is supplied, this indexing operation is chained.  For example, if
\code{a} is a two-dimensional array, then \code{a[m,~n]} is just
a convenient shorthand for \code{a[m][n]}.
%
Vectors, matrices, and arrays are not assignable to one another, even
if their dimensions are identical.

\subsection{Declaring Array Variables}

Arrays are declared by enclosing the dimensions in square brackets
following the name of the variable.

The variable \code{n} is declared as an array of five integers as follows.
%
\begin{stancode}
int n[5];
\end{stancode}
%
A two-dimensional array of real values with three rows and four columns is
declared with the following.
%
\begin{stancode}
real a[3, 4];
\end{stancode}
%
A three-dimensional array \code{z} of positive reals with five rows, four
columns, and two shelves can be declared as follows.
%
\begin{stancode}
real<lower=0> z[5, 4, 2];
\end{stancode}
%

Arrays may also be declared to contain vectors.  For example,
%
\begin{stancode}
vector[7] mu[3];
\end{stancode}
%
declares \code{mu} to be an array of size 3 containing vectors with 7
elements.  Arrays may also contain matrices.  The example
%
\begin{stancode}
matrix[7, 2] mu[15, 12];
\end{stancode}
%
declares a 15 by 12 array of $7 \times 2$ matrices.
Any of the constrained types may also be used in arrays, as in the
declaration
%
\begin{stancode}
cholesky_factor_cov[5, 6] mu[2, 3, 4];
\end{stancode}
%
of a $2 \times 3 \times 4$ array of $5 \times 6$ Cholesky factors of
covariance matrices.

\subsection{Accessing Array Elements and Subarrays}

If \code{x} is a 1-dimensional array of length 5, then \code{x[1]} is
the first element in the array and \code{x[5]} is the last.  For a $3
\times 4$ array \code{y} of two dimensions, \code{y[1,~1]} is the first
element and \code{y[3,~4]} the last element.  For a three-dimensional
array \code{z}, the first element is \code{z[1,~1,~1]}, and so on.

Subarrays of arrays may be accessed by providing fewer than the full
number of indexes.  For example, suppose \code{y} is a two-dimensional
array with three rows and four columns.  Then \code{y[3]} is
one-dimensional array of length four.  This means that \code{y[3][1]}
may be used instead of \code{y[3,~1]} to access the value of the first
column of the third row of \code{y}.  The form \code{y[3,~1]} is the
preferred form (see \refnote{array-index-style} in this chapter).

\subsection{Assigning}

Subarrays may be manipulated and assigned just like any other
variables.  Similar to the behavior of matrices, Stan allows blocks
such as
%
\begin{stancode}
real w[9, 10, 11];
real x[10, 11];
real y[11];
real z;
// ...
x = w[5];
y = x[4];  // y == w[5][4] == w[5, 4]
z = y[3];  // z == w[5][4][3] == w[5, 4, 3]
\end{stancode}
%


\subsection{Arrays of Matrices and Vectors}

Arrays of vectors and matrices are accessed in the same way as arrays
of doubles.  Consider the following vector and scalar declarations.
%
\begin{stancode}
vector[5] a[3, 4];
vector[5] b[4];
vector[5] c;
real x;
\end{stancode}
%
With these declarations, the following assignments are legal.
%
\begin{stancode}
b = a[1];      // result is array of vectors
c = a[1, 3];    // result is vector
c = b[3];      //   same result as above
x = a[1, 3, 5];  // result is scalar
x = b[3, 5];    //   same result as above
x = c[5];      //   same result as above
\end{stancode}
%
Row vectors and other derived vector types (simplex and ordered)
behave the same way in terms of indexing.

Consider the following matrix, vector and scalar declarations.
%
\begin{stancode}
matrix[6, 5] d[3, 4];
matrix[6, 5] e[4];
matrix[6, 5] f;
row_vector[5] g;
real x;
\end{stancode}
%
With these declarations, the following definitions are legal.
%
\begin{stancode}
e = d[1];        // result is array of matrices
f = d[1,3];      // result is matrix
f = e[3];        //   same result as above
g = d[1,3,2];    // result is row vector
g = e[3,2];      //   same result as above
g = f[2];        //   same result as above
x = d[1,3,5,2];  // result is scalar
x = e[3,5,2];    //   same result as above
x = f[5,2];      //   same result as above
x = g[2];        //   same result as above
\end{stancode}
%
As shown, the result \code{f[2]} of supplying a single index to a
matrix is the indexed row, here row 2 of matrix \code{f}.


\subsection{Partial Array Assignment}

Subarrays of arrays may be assigned by indexing on the left-hand side
of an assignment statement.  For example, the following is legal.
%
\begin{stancode}
real x[I,J,K];
real y[J,K];
real z[K];
// ...
x[1] = y;
x[1,1] = z;
\end{stancode}
%
The sizes must match.  Here, \code{x[1]} is a \code{J} by \code{K}
array, as is is \code{y}.

Partial array assignment also works for arrays of matrices, vectors,
and row vectors.


\subsection{Mixing Array, Vector, and Matrix Types}

Arrays, row vectors, column vectors and matrices are not
interchangeable in Stan.  Thus a variable of any one of these
fundamental types is not assignable to any of the others, nor may it
be used as an argument where the other is required (use as arguments
follows the assignment rules).



\subsubsection{Mixing Vectors and Arrays}

For example, vectors cannot be assigned to arrays or vice-versa.
%
\begin{stancode}
real a[4];
vector[4] b;
row_vector c[4];
// ...
a = b; // illegal assignment of vector to array
b = a; // illegal assignment of array to vector
a = c; // illegal assignment of row vector to array
c = a; // illegal assignment of array to row vector
\end{stancode}

\subsubsection{Mixing Row and Column Vectors}

It is not even legal to assign row vectors to column vectors or vice
versa.
\begin{stancode}
vector b[4];
row_vector c[4];
// ...
b = c; // illegal assignment of row vector to column vector
c = b; // illegal assignment of column vector to row vector
\end{stancode}
%

\subsubsection{Mixing Matrices and Arrays}

The same holds for matrices, where 2-dimensional arrays may not be
assigned to matrices or vice-versa.

\begin{stancode}
real a[3,4];
matrix[3,4] b;
// ...
a = b;  // illegal assignment of matrix to array
b = a;  // illegal assignment of array to matrix
\end{stancode}
%

\subsubsection{Mixing Matrices and Vectors}

A $1 \times N$ matrix cannot be assigned a row vector or
vice versa.
%
\begin{stancode}
matrix[1,4] a;
row_vector[4] b;
// ...
a = b;  // illegal assignment of row vector to matrix
b = a;  // illegal assignment of matrix to row vector
\end{stancode}
%
Similarly, an $M \times 1$ matrix may not be assigned to a column vector.
%
\begin{stancode}
matrix[4,1] a;
vector[4] b;
// ...
a = b;  // illegal assignment of column vector to matrix
b = a;  // illegal assignment of matrix to column vector
\end{stancode}

\subsection{Size Declaration Restrictions}

An integer expression is used to pick out the sizes of arrays.  The
same restrictions as for vector and matrix sizes apply, namely that
the size is declared with an integer-denoting expression that does not
contain any parameters, transformed parameters, or generated quantities.

\subsection{Size Zero Arrays}

If any of an array's dimensions is size zero, the entire array will be
of size zero.  That is, if we declare
%
\begin{stancode}
real a[3, 0];
\end{stancode}
%
then the resulting size of \code{a} is zero and querying any of its
dimensions at run time will result in the value zero.  Declared as
above, \code{a[1]} will be a size-zero one-dimensional array.  For
comparison, declaring
%
\begin{stancode}
real b[0, 3];
\end{stancode}
%
also produces an array with an overall size of zero, but in this case,
there is no way to index legally into \code{b}, because \code{b[0]} is
undefined.  The array will behave at run time as if it's a $0 \times
0$ array.  For example, the result of \code{to\_matrix(b)} will be a
$0 \times 0$ matrix, not a $0 \times 3$ matrix.


\section{Variable Types vs.\ Constraints and Sizes}

The type information associated with a variable only contains the
underlying type and dimensionality of the variable.

\subsection{Type Information Excludes Sizes}

The size associated with a given variable is not part of its data
type.  For example, declaring a variable using
\begin{stancode}
real a[3];
\end{stancode}
%
declares the variable \code{a} to be an array.  The fact that it was
declared to have size 3 is part of its declaration, but not part of
its underlying type.

\subsubsection{When are Sizes Checked?}

Sizes are determined dynamically (at run time) and thus cannot be
type-checked statically when the program is compiled.  As a result,
any conformance error on size will raise a run-time error.  For
example, trying to assign an array of size 5 to an array of size 6
will cause a run-time error.  Similarly, multiplying an $N
\times M$ by a $J \times K$ matrix will raise a run-time error if $M
\neq J$.

\subsection{Type Information Excludes Constraints}

Like sizes, constraints are not treated as part of a variable's type
in Stan when it comes to the compile-time check of operations it may
participate in.  Anywhere Stan accepts a matrix as an argument, it
will syntactically accept a correlation matrix or covariance matrix or
Cholesky factor.  Thus a covariance matrix may be assigned to a matrix
and vice-versa.

Similarly, a bounded real may be assigned to an unconstrained real and
vice-versa.

\subsubsection{When are Function Argument Constraints Checked?}

For arguments to functions, constraints are sometimes, but not always
checked when the function is called.  Exclusions include \Cpp standard
library functions.  All probability functions and cumulative
distribution functions check that their arguments are appropriate at
run time as the function is called.

\subsubsection{When are Declared Variable Constraints Checked?}

For data variables, constraints are checked after the variable is read
from a data file or other source.  For transformed data variables, the
check is done after the statements in the transformed data block have
executed.  Thus it is legal for intermediate values of variables to
not satisfy declared constraints.

For parameters, constraints are enforced by the transform applied and
do not need to be checked.  For transformed parameters, the check is
done after the statements in the transformed parameter block have
executed.

For all blocks defining variables (transformed data, transformed
parameters, generated quantities), real values are initialized to
\code{NaN} and integer values are initialized to the smallest legal
integer (i.e., a large absolute value negative number).

For generated quantities, constraints are enforced after the
statements in the generated quantities block have executed.


\subsection{Type Naming Notation}

In order to refer to data types, it is convenient to have a way to
refer to them.  The type naming notation outlined in this section is
not part of the Stan programming language, but rather a convention
adopted in this document to enable a concise description of a type.

Because size information is not part of a data type, data
types will be written without size information.  For instance,
\code{real[]} is the type of one-dimensional array of reals and
\code{matrix} is the type of matrices.  The three-dimensional integer
array type is written as \code{int[\, , \, ,]}, indicating the number slots
available for indexing.  Similarly, \code{vector[~,~]} is the type of a
two-dimensional array of vectors.


\section{Compound Variable Declaration and Definition}

Stan allows assignable variables to be declared and defined in a
single statement.  Assignable variables are 
%
\begin{itemize}
\item local variables, and
\item variables declared in the transformed data,
transformed parameters, or generated quantities blocks.
\end{itemize}
%
For example, the statement
%
\begin{stancode}
int N = 5;
\end{stancode}
%
declares the variable \code{N} to be an integer scalar type and at the
same time defines it to be the value of the expression \code{5}.  

\subsection{Assignment Typing}

The type of the expression on the right-hand side of the assignment
must be assignable to the type of the variable being declared.  For
example, it is legal to have
%
\begin{stancode}
real sum = 0;
\end{stancode}
%
even though \code{0} is of type \code{int} and \code{sum} is of type
\code{real}, because integer-typed scalar expressions can be assigned
to real-valued scalar variables.  In all other cases, the type of the
expression on the right-hand side of the assignment must be identical
to the type of the variable being declared.

Any type may be assigned.  For example,
%
\begin{stancode}
matrix[3, 2] a = b;
\end{stancode}
%
declares a matrix variable \code{a} and assigns it to the value of
\code{b}, which must be of type \code{matrix} for the compound
statement to be well formed.  The sizes of matrices are not part of
their static typing and cannot be validated until run time.


\subsection{Right-Hand Side Expressions}

The right-hand side may be any expression which has a type which is
assignable to the variable being declared.  For example,
%
\begin{stancode}
matrix[3, 2] a = 0.5 * (b + c);
\end{stancode}
%
assigns the matrix variable \code{a} to half of the sum of \code{b}
and \code{c}.  The only requirement on \code{b} and \code{c} is that
the expression \code{b~+~c} be of type \code{matrix}.  For example,
\code{b} could be of type \code{matrix} and \code{c} of type
\code{real}, because adding a matrix to a scalar produces a matrix,
and the multiplying by a scalar produces another matrix.

The right-hand side expression can be a call to a user defined
function, allowing general algorithms to be applied that might not be
otherwise expressible as simple expressions (e.g., iterative or
recursive algorithms).


\subsection{Scope within Expressions}

Any variable that is in scope and any function that is available in
the block in which the compound declaration and definition appears may
be used in the expression on the right-hand side of the compound
declaration and definition statement. 

\chapter{Expressions}

\noindent
An expression is the basic syntactic unit in a Stan program that
denotes a value.  Every expression in a well-formed Stan program has
a type that is determined statically (at compile time).  If an
expressions type cannot be determined statically, the Stan compiler
will report the location of the problem.

This chapter covers the syntax, typing, and usage of the various forms
of expressions in Stan.

\section{Numeric Literals}

The simplest form of expression is a literal that denotes a primitive
numerical value.

\subsection{Integer Literals}

Integer literals represent integers of type \code{int}.  Integer
literals are written in base 10 without any separators.  Integer
literals may contain a single negative sign.  (The expression
\code{{-}-1} is interpreted as the negation of the literal \code{-1}.)

The following list contains well-formed integer literals.
%
\begin{quote}
\code{0}, \ \code{1}, \ \code{-1}, \ \code{256},
\ \code{-127098}, \ \code{24567898765}
\end{quote}
%
Integer literals must have values that fall within the bounds for
integer values (see \refsection{numerical-data-types}).

Integer literals may not contain decimal points (\code{.}).  Thus the
expressions \code{1.} and \code{1.0} are of type \code{real} and may
not be used where a value of type \code{int} is required.

\subsection{Real Literals}

A number written with a period or with scientific notation is assigned
to a the continuous numeric type \code{real}.  Real literals are
written in base 10 with a period (\code{.}) as a separator.  Examples
of well-formed real literals include the following.
%
\begin{quote}
\code{0.0}, \ \code{1.0}, \ \code{3.14}, \ \code{-217.9387}, \
\code{2.7e3}, \ \code{-2E-5}
\end{quote}
%
The notation \code{e} or \code{E} followed by a positive or negative
integer denotes a power of 10 to multiply.  For instance, \code{2.7e3}
denotes $2.7 \times 10^3$ and \code{-2E-5} denotes $-2 \times
10^{-5}$.


\section{Variables}\label{variables.section}

A variable by itself is a well-formed expression of the same type as
the variable.  Variables in Stan consist of \ASCII strings containing
only the basic lower-case and upper-case Roman letters, digits, and
the underscore (\code{\_}) character.  Variables must start with a
letter (\code{a--z} and \code{A--Z}) and may not end with two underscores
(\code{\_\_}).

Examples of legal variable identifiers are as follows.
%
\begin{quote}
\code{a},
\ \code{a3},
\ \code{a\_3},
\ \code{Sigma},
\ \code{my\_cpp\_style\_variable},
\ \code{myCamelCaseVariable}
\end{quote}
%
Unlike in \R and \BUGS, variable identifiers in Stan may not contain
a period character.

\subsection{Reserved Names}

Stan reserves many strings for internal use and these may not be used
as the name of a variable.  An attempt to name a variable after an
internal string results in the \code{stanc} translator halting with an
error message indicating which reserved name was used and its location
in the model code.

\subsubsection{Model Name}

The name of the model cannot be used as a variable within the model.
This is usually not a problem because the default in \code{bin/stanc}
is to append \code{\_model} to the name of the file containing the
model specification.  For example, if the model is in file
\code{foo.stan}, it would not be legal to have a variable named
\code{foo\_model} when using the default model name through
\code{bin/stanc}.  With user-specified model names, variables cannot
match the model.

\subsubsection{User-Defined Function Names}

User-defined function names cannot be used as a variable within the
model.

\subsubsection{Reserved Words from Stan Language}

The following list contains reserved words for Stan's programming
language.  Not all of these features are implemented in Stan yet, but
the tokens are reserved for future use.
%
\begin{quote}
\code{for},
\code{in},
\code{while},
\code{repeat},
\code{until},
\code{if},
\code{then},
\code{else},
\code{true},
\code{false}
\end{quote}
%
Variables should not be named after types, either, and thus may not be
any of the following.
%
\begin{quote}
\code{int},
\code{real},
\code{vector},
\code{simplex},
\code{unit\_vector},
\code{ordered},
\code{positive\_ordered},
\code{row\_vector},
\code{matrix},
\code{cholesky\_factor\_corr},
\code{cholesky\_factor\_cov},
\code{corr\_matrix},
\code{cov\_matrix}.
\end{quote}
%
Variable names will {\it not}\ conflict with the following block identifiers,
%
\begin{quote}
\code{functions},
\code{model},
\code{data},
\code{parameters},
\code{quantities},
\code{transformed},
\code{generated},
\end{quote}
%

\subsubsection{Reserved Names from Stan Implementation}

Some variable names are reserved because they are used within
Stan's \Cpp implementation.  These are
%
\begin{quote}
\code{var},
\code{fvar},
\code{STAN\_MAJOR},
\code{STAN\_MINOR},
\code{STAN\_PATCH},
\code{STAN\_MATH\_MAJOR},
\code{STAN\_MATH\_MINOR},
\code{STAN\_MATH\_PATCH}
\end{quote}
%

\subsubsection{Reserved Function and Distribution Names}

Variable names will conflict with the names of predefined functions
other than constants.  Thus a variable may not be named \code{logit}
or \code{add}, but it may be named \code{pi} or \code{e}.

Variable names will also conflict with the names of distributions
suffixed with \code{\_lpdf}, \code{\_lpmf}, \code{\_lcdf}, and
\code{\_lccdf}, \code{\_cdf}, and \code{\_ccdf}, such as
\code{normal\_lcdf\_log}; this also holds for the deprecated forms
\code{\_log}, \code{\_cdf\_log}, and \code{\_ccdf\_log},

Using any of these variable names causes the \code{stanc} translator
to halt and report the name and location of the variable causing the
conflict.


\subsubsection{Reserved Names from C++}

Finally, variable names, including the names of models, should not
conflict with any of the C++ keywords.
%
\begin{quote}
\code{alignas},
\code{alignof},
\code{and},
\code{and\_eq},
\code{asm},
\code{auto},
\code{bitand},
\code{bitor},
\code{bool},
\code{break},
\code{case},
\code{catch},
\code{char},
\code{char16\_t},
\code{char32\_t},
\code{class},
\code{compl},
\code{const},
\code{constexpr},
\code{const\_cast},
\code{continue},
\code{decltype},
\code{default},
\code{delete},
\code{do},
\code{double},
\code{dynamic\_cast},
\code{else},
\code{enum},
\code{explicit},
\code{export},
\code{extern},
\code{false},
\code{float},
\code{for},
\code{friend},
\code{goto},
\code{if},
\code{inline},
\code{int},
\code{long},
\code{mutable},
\code{namespace},
\code{new},
\code{noexcept},
\code{not},
\code{not\_eq},
\code{nullptr},
\code{operator},
\code{or},
\code{or\_eq},
\code{private},
\code{protected},
\code{public},
\code{register},
\code{reinterpret\_cast},
\code{return},
\code{short},
\code{signed},
\code{sizeof},
\code{static},
\code{static\_assert},
\code{static\_cast},
\code{struct},
\code{switch},
\code{template},
\code{this},
\code{thread\_local},
\code{throw},
\code{true},
\code{try},
\code{typedef},
\code{typeid},
\code{typename},
\code{union},
\code{unsigned},
\code{using},
\code{virtual},
\code{void},
\code{volatile},
\code{wchar\_t},
\code{while},
\code{xor},
\code{xor\_eq}
\end{quote}

\subsection{Legal Characters}

The legal variable characters have the same \ASCII code points in the
range 0--127 as in Unicode.
%
\begin{center}
\begin{tabular}{cc}
Characters  & \ASCII (Unicode) Code Points
\\ \hline
\code{a -- z} & \code{{}~97 -- 122}
\\
\code{A -- Z} & \code{{}~65 -- {}~90}
\\
\code{0 -- 9} & \code{{}~48 -- {}~57}\
\\
\code{\_} & \code{95}
\end{tabular}
\end{center}
%
Although not the most expressive character set, \ASCII is the most
portable and least prone to corruption through improper character
encodings or decodings.

\subsubsection{Comments Allow ASCII-Compatible Encoding}

Within comments, Stan can work with any ASCII-compatible character
encoding, such as ASCII itself, UTF-8, or Latin1.  It is up to user
shells and editors to display them properly.


\section{Vector, Matrix, and Array Expressions}

Expressions for the Stan container objects arrays, vectors, and
matrices can be constructed via a sequence of expressions
enclosed in either curly braces for arrays, or square brackets for
vectors and matrices.

\subsection{Vector Expressions}

Square brackets may be wrapped around a sequence of comma separated
primitive expressions to produce a row vector expression.   For
example, the expression \Verb|[ 1, 10, 100 ]| denotes a row vector of
three elements with real values 1.0, 10.0, and 100.0.
Applying the transpose operator to a row vector expression produces 
a vector expression.
This syntax provides a way declare and define small vectors a single line, as follows.

%
\begin{stancode}
row_vector[2] rv2=  [ 1, 2 ];
vector[3] v3 = [ 3, 4, 5 ]';
\end{stancode}
%

The vector expression values may be compound expressions
or variable names,  so it is legal to write 
\Verb|[ 2 * 3, 1 + 4]|  or \Verb|[ x, y ]|, providing that \Verb|x|
and \Verb|y| are primitive variables.

\subsection{Matrix Expressions}

A matrix expression consists of square brackets wrapped
around a sequence of comma separated row vector expressions.
This syntax provides a way declare and define a matrix in a single
line, as follows.

%
\begin{stancode}
matrix[3,2] m1 = [ [ 1, 2 ], [ 3, 4 ], [5, 6 ] ];
\end{stancode}
%

Any expression denoting a row vector can be used in a matrix expression.
For example, the following code is valid:

%
\begin{stancode}
vector[2] vX = [ 1, 10 ]';
row_vector[2] vY = [ 100, 1000 ];
matrix[3,2] m2 = [ vX', vY, [ 1, 2 ]  ];
\end{stancode}
%

\subsubsection{No empty vector or matrix expressions}

The empty expression \Verb|[ ]| is ambiguous and therefore is not
allowed and similarly expressions such as \Verb|[ [ ] ]| or
\Verb|[ [ ], [ ] ]| are not allowed.

\subsection{Array Expressions}

Curly braces may be wrapped around a sequence of expressions to
produce an array expression.  For example, the expression
\Verb|{ 1, 10, 100 }| denotes an integer array of three elements with
values 1, 10, and 100.  This syntax is particularly convenient to
define small arrays in a single line, as follows.
%
\begin{stancode}
int a[3] = { 1, 10, 100 };
\end{stancode}
%

The values may be compound expressions, so it is legal to write
\Verb|{ 2 * 3, 1 + 4 }|. It is also possible to write two dimensional
arrays directly, as in the following example.
%
\begin{stancode}
int b[2, 3] = { { 1, 2, 3 }, { 4, 5, 6 } };
\end{stancode}
%
This way, \code{b[1]} is \Verb|{ 1, 2, 3 }| and \code{b[2]} is 
\Verb|{ 4, 5, 6 }|.

Whitespace is always interchangeable in Stan, so the above can be laid
out as follows to more clearly indicate the row and column structure
of the resulting two dimensional array.
%
\begin{stancode}
int b[2, 3] = { { 1, 2, 3 },
                { 4, 5, 6 } };
\end{stancode}
%

\subsection{Array Expression Types}

Any type of expression may be used within braces to form an array
expression.  In the simplest case, all of the elements will be of the
same type and the result will be an array of elements of that type.
For example, the elements of the array can be vectors, in which case
the result is an array of vectors.
%
\begin{stancode}
vector[3] b;
vector[3] c;
...
vector[3] d[2] = { b, c };
\end{stancode}
%
The elements may also be a mixture of \code{int} and \code{real} typed
expressions, in which case the result is an array of real values.
%
\begin{stancode}
real b[2] = { 1, 1.9 };
\end{stancode}
%

\subsection{Restrictions on Values}

There are some restrictions on how array expressions may be used that
arise from their types being calculated bottom up and the basic data
type and assignment rules of Stan.

\subsubsection{Rectangular array expressions only}

Although it is tempting to try to define a ragged array expression,
all Stan data types are rectangular (or boxes or other
higher-dimensional generalizations).  Thus the following nested array
expression will cause an error when it tries to create a
non-rectangular array.
%
\begin{stancode}
{ { 1, 2, 3 }, { 4, 5 } }  // compile time error: size mismatch
\end{stancode}
%
This may appear to be OK, because it is creating a two-dimensional
integer array (\code{int[~,~]}) out of two one-dimensional array
integer arrays (\code{int[~]}).  But it is not allowed because the two
one-dimensional arrays are not the same size.  If the elements are
array expressions, this can be diagnosed at compile time.  If one or
both expressions is a variable, then that won't be caught until
runtime.  
%
\begin{stancode}
{ { 1, 2, 3 }, m }  // runtime error if m not size 3
\end{stancode}


\subsubsection{No empty array expressions}

Because there is no way to infer the type of the result, the empty
array expression (\Verb|{ }|) is not allowed.  This does not sacrifice
expressive power, because a declaration is sufficient to initialize a
zero-element array.
%
\begin{stancode}
int a[0];   // a is fully defined as zero element array
\end{stancode}


\subsubsection{Integer only array expressions}

If an array expression contains only integer elements, such as 
\Verb|{ 1, 2, 3 }|, then the result type will be an integer array,
\code{int[]}.  This means that the following will \emph{not}\ be
legal. 
%
\begin{stancode}
real a[2] = { -3, 12 };  // error: int[] can't be assigned to real[]
\end{stancode}
%
Integer arrays may not be assigned to real values.  However, this
problem is easily sidestepped by using real literal expressions.  
%
\begin{stancode}
real a[2] = { -3.0, 12.0 };
\end{stancode}
%
Now the types match and the assignment is allowed.


\section{Parentheses for Grouping}

Any expression wrapped in parentheses is also an expression. Like in
\Cpp, but unlike in \R, only the round parentheses, \code{(} and
\code{)}, are allowed.  The square brackets \code{[} and \code{]} are
reserved for array indexing and the curly braces \code{\{} and
\code{\}} for grouping statements.

With parentheses it is possible to explicitly group subexpressions
with operators.  Without parentheses, the expression \code{1 + 2 * 3}
has a subexpression \code{2 * 3} and evaluates to 7.  With
parentheses, this grouping may be made explicit with the expression
\code{1 + (2 * 3)}.  More importantly, the expression \code{(1 + 2) *
  3} has \code{1 + 2} as a subexpression and evaluates to 9.


\section{Arithmetic and Matrix Operations on Expressions}\label{arithmetic-expressions.section}

For integer and real-valued expressions, Stan supports the basic
binary arithmetic operations of addition (\code{+}), subtraction
(\code{-}), multiplication (\code{*}) and division (\code{/}) in the
usual ways.

For integer expressions, Stan supports the modulus (\code{\%}) binary
arithmetic operation.  Stan also supports the unary operation of
negation for integer and real-valued expressions.  For example,
assuming \code{n} and \code{m} are integer variables and \code{x} and
\code{y} real variables, the following expressions are legal.
%
\begin{quote}
\code{3.0 + 0.14},
\ \ \code{-15},
\ \ \code{2 * 3 + 1},
\ \ \code{(x - y) / 2.0},
\\
\ \ \code{(n * (n + 1)) / 2},
\ \ \code{x / n},
\ \ \code{m \% n}
\end{quote}
%
The negation, addition, subtraction, and multiplication operations are
extended to matrices, vectors, and row vectors.  The transpose
operation, written using an apostrophe (\code{'}) is also supported
for vectors, row vectors, and matrices.  Return types for matrix
operations are the smallest types that can be statically guaranteed to
contain the result.  The full set of allowable input types and
corresponding return types is detailed in
\refchapter{matrix-operations}.

For example, if \code{y} and \code{mu} are variables of type
\code{vector} and \code{Sigma} is a variable of type \code{matrix},
then
%
\begin{quote}
\code{(y - mu)' * Sigma * (y - mu)}
\end{quote}
%
is a well-formed expression of type \code{real}.  The type of the
complete expression is inferred working outward from the
subexpressions.  The subexpression(s) \code{y - mu} are of type
\code{vector} because the variables \code{y} and \code{mu} are of type
\code{vector}.  The transpose of this expression, the subexpression
\code{(y - mu)'} is of type \code{row\_vector}.  Multiplication is
left associative and transpose has higher precedence than
multiplication, so the above expression is equivalent to the following
well-formed, fully specified form.
%
\begin{quote}
\code{(((y - mu)') * Sigma) * (y - mu)}
\end{quote}
%
The type of subexpression \code{(y - mu)' * Sigma} is inferred to be
\code{row\_vector}, being the result of multiplying a row vector by a
matrix.  The whole expression's type is thus the type of a row vector
multiplied by a (column) vector, which produces a \code{real} value.

Stan provides elementwise matrix division and multiplication
operations, \code{a~.*~b} and \code{a~./b}.  These provide a shorthand
to replace loops, but are not intrinsically more efficient than a
version programmed with an elementwise calculations and assignments in
a loop.  For example, given declarations,
%
\begin{stancode}
vector[N] a;
vector[N] b;
vector[N] c;
\end{stancode}
%
the assignment,
%
\begin{stancode}
c = a .* b;
\end{stancode}
%
produces the same result with roughly the same efficiency as the loop
%
\begin{stancode}
for (n in 1:N)
  c[n] = a[n] * b[n];
\end{stancode}

Stan supports exponentiation (\code{\textasciicircum}) of integer and
real-valued expressions.  The return type of exponentiation is always
a real-value.  For example, assuming \code{n} and \code{m} are integer
variables and \code{x} and \code{y} real variables, the following
expressions are legal.
%
\begin{quote}
\code{3 \textasciicircum\ 2},
\ \ \code{3.0 \textasciicircum\ -2},
\ \ \code{3.0 \textasciicircum\ 0.14},
\\
\ \ \code{x \textasciicircum\ n},
\ \ \code{n \textasciicircum\ x},
\ \ \code{n \textasciicircum\ m},
\ \ \code{x \textasciicircum\ y}
\end{quote}
%
Exponentiation is right associative, so the expression
%
\begin{quote}
\code{2 \textasciicircum\ 3 \textasciicircum\ 4}
\end{quote}
%
is equivalent to the following well-formed, fully specified form.
%
\begin{quote}
\code{2 \textasciicircum\ (3 \textasciicircum\ 4)}
\end{quote}
%



\subsection{Operator Precedence and Associativity}

The precedence and associativity of operators, as well as built-in
syntax such as array indexing and function application is given in
tabular form in \reffigure{operator-precedence}.
%
\begin{figure}
\begin{center}
\begin{tabular}{c|ccl|l}
{\it Op.} & {\it Prec.} & {\it Assoc.} & {\it
  Placement} & {\it Description}
\\ \hline \hline
\code{?~:} & 10 & right & ternary infix & conditional
\\ \hline
\code{||} & 9 & left & binary infix & logical or
\\ \hline
\Verb|&&| & 8 & left & binary infix & logical and
\\ \hline
\Verb|==| & 7 & left & binary infix & equality
\\
\Verb|!=| & 7 & left & binary infix & inequality
\\ \hline
\Verb|<| & 6 & left & binary infix & less than
\\
\Verb|<=| & 6 & left & binary infix & less than or equal
\\
\Verb|>| & 6 & left & binary infix & greater than
\\
\Verb|>=| & 6 & left & binary infix & greater than or equal
\\ \hline
\code{+} & 5 & left & binary infix & addition
\\
\code{-} & 5 & left & binary infix & subtraction
\\ \hline
\code{*} & 4 & left & binary infix & multiplication
\\
\code{/} & 4 & left & binary infix & (right) division
\\
\code{\%} & 4 & left & binary infix & modulus
\\ \hline
\Verb|\| & 3 & left & binary infix & left division
\\ \hline
\code{.*} & 2 & left & binary infix & elementwise multiplication
\\
\code{./} & 2 & left & binary infix & elementwise division
\\ \hline
\code{!} & 1 & n/a & unary prefix & logical negation
\\
\code{-} & 1 & n/a & unary prefix & negation
\\
\code{+} & 1 & n/a & unary prefix & promotion (no-op in Stan)
\\ \hline
\code{\textasciicircum} & 0.5 & right & binary infix & exponentiation
\\ \hline
\code{'} & 0 & n/a & unary postfix & transposition
\\ \hline \hline
\code{()} & 0 & n/a & prefix, wrap & function application
\\
\code{[]} & 0 & left & prefix, wrap & array, matrix indexing
\end{tabular}
\end{center}
\caption{\small\it Stan's unary, binary, and ternary operators, with their
  precedences, associativities, place in an expression, and a
  description.  The last two lines list the precedence of function
  application and array, matrix, and vector indexing. The operators are
  listed in order of precedence, from least tightly binding to most
  tightly binding.  The full set of legal arguments and corresponding
  result types are provided in the function documentation in
  \refpart{built-in-functions} prefaced with \code{operator} (i.e.,
  \code{operator*(int,int):int} indicates the application of the
  multiplication operator to two integers, which returns an integer).
  Parentheses may be used to group expressions explicitly rather than
  relying on precedence and
  associativity.}\label{operator-precedence.figure}
\end{figure}
%
Other expression-forming operations, such as function application and
subscripting bind more tightly than any of the arithmetic operations.

The precedence and associativity determine how expressions are
interpreted.  Because addition is left associative, the expression
\mbox{\code{a+b+c}} is interpreted as \mbox{\code{(a+b)+c}}.  Similarly,
\mbox{\code{a/b*c}} is interpreted as \mbox{\code{(a/b)*c}}.

Because multiplication has higher precedence than addition, the
expression \mbox{\code{a*b+c}} is interpreted as \mbox{\code{(a*b)+c}} and the
expression \mbox{\code{a+b*c}} is interpreted as \mbox{\code{a+(b*c)}}.  Similarly,
\mbox{\code{2*x+3*-y}} is interpreted as \mbox{\code{(2*x)+(3*(-y))}}.

Transposition and exponentiation bind more tightly
than any other arithmetic or logical operation.
For vectors, row vectors, and matrices,
\mbox{\code{-u'}} is interpreted as \mbox{\code{-(u')}}, \mbox{\code{u*v'}} as
\mbox{\code{u*(v')}}, and \mbox{\code{u'*v}} as \mbox{\code{(u')*v}}.
For integer and reals,
\mbox{\code{-n \textasciicircum\ 3}}
is interpreted as \mbox{\code{-(n \textasciicircum\ 3)}}.


\section{Conditional Operator}\label{conditional-operator.section}

\subsection{Conditional Operator Syntax}

The ternary conditional operator is unique in that it takes three
arguments and uses a mixed syntax.  If \code{a} is an expression of
type \code{int} and \code{b} and \code{c} are expressions that can be
converted to one another (e.g., compared with \code{==}), then 
%
\begin{stancode}
a ? b : c
\end{stancode}
%
is an expression of the promoted type of \code{b} and \code{c}.  The
only promotion allowed in Stan is from integer to real; if one
argument is of type \code{int} and the other of type \code{real}, the
conditional expression as a whole is of type \code{real}.  In all
other cases, the arguments have to be of the same underlying Stan type
(i.e., constraints don't count, only the shape) and the conditional
expression is of that type.

\subsubsection{Conditional Operator Precedence}

The conditional operator is the most loosely binding operator, so its
arguments rarely require parentheses for disambiguation.  For example,
%
\begin{stancode}
a > 0 || b < 0 ? c + d : e - f
\end{stancode}
%
is equivalent to the explicitly grouped version
%
\begin{stancode}
(a > 0 || b < 0) ? (c + d) : (e - f)
\end{stancode}
%
The latter is easier to read even if the parentheses are not strictly
necessary.

\subsubsection{Conditional Operator Associativity}

The conditional operator is right associative, so that
%
\begin{stancode}
a ? b : c ? d : e
\end{stancode}
%
parses as if explicitly grouped as
%
\begin{stancode}
a ? b : (c ? d : e)
\end{stancode}
%
Again, the explicitly grouped version is easier to read.


\subsection{Conditional Operator Semantics}

Stan's conditional operator works very much like its C++ analogue.
The first argument must be an expression denoting an integer.
Typically this is a variable or a relation operator, as in the
variable \code{a} in the example above.  Then there are two resulting
arguments, the first being the result returned if the condition
evaluates to true (i.e., non-zero) and the second if the condition
evaluates to false (i.e., zero).  In the example above, the value
\code{b} is returned if the condition evaluates to a non-zero value
and \code{c} is returned if the condition evaluates to zero.

\subsubsection{Lazy Evaluation of Results}

The key property of the conditional operator that makes it so useful
in high-performance computing is that it only evaluates the returned
subexpression, not the alternative expression.  In other words, it is
not like a typical function that evaluates its argument expressions
eagerly in order to pass their values to the function.  As usual, the
saving is mostly in the derivatives that do not get computed rather
than the unnecessary function evaluation itself.

\subsubsection{Promotion to Parameter}

If one return expression is a data value (an expression involving only
constants and variables defined in the data or transformed data
block), and the other is not, then the ternary operator will promote
the data value to a parameter value.  This can cause needless work
calculating derivatives in some cases and be less efficient than a full
\code{if}-\code{then} conditional statement.  For example,
%
\begin{stancode}
data {
  real x[10];
  ...
parameters {
  real z[10];
  ...
model {
  y ~ normal(cond ? x : z, sigma);
  ...
\end{stancode}
%
would be more efficiently (if not more transparently) coded as
%
\begin{stancode}
if (cond)
  y ~ normal(x, sigma);
else
  y ~ normal(z, sigma);
\end{stancode}
%
The conditional statement, like the conditional operator, only
evaluates one of the result statements.  In this case, the variable
\code{x} will not be promoted to a parameter and thus not cause any
needless work to be carried out when propagating the chain rule during
derivative calculations.


\section{Indexing}\label{language-indexing.section}

Stan arrays, matrices, vectors, and row vectors are all accessed
using the same array-like notation.  For instance, if \code{x} is a
variable of type \code{real[]} (a one-dimensional array of reals)
then \code{x[1]} is the value of the first element of the
array.

Subscripting has higher precedence than any of the arithmetic
operations.  For example, \code{alpha*x[1]} is equivalent to
\code{alpha*(x[1])}.

Multiple subscripts may be provided within a single pair of square
brackets.  If \code{x} is of type \code{real[~,~]}, a two-dimensional
array, then \code{x[2,501]} is of type \code{real}.

\subsection{Accessing Subarrays}

The subscripting operator also returns subarrays of arrays.  For
example, if \code{x} is of type \code{real[~,~,~]}, then \code{x[2]}
is of type \code{real[~,~]}, and \code{x[2,3]} is of type
\code{real[]}.  As a result, the expressions \code{x[2,3]} and
\code{x[2][3]} have the same meaning.

\subsection{Accessing Matrix Rows}

If \code{Sigma} is a variable of type \code{matrix}, then
\code{Sigma[1]} denotes the first row of \code{Sigma} and has the
type \code{row\_vector}.

\subsection{Mixing Array and Vector/Matrix Indexes}

Stan supports mixed indexing of arrays and their vector, row vector
or matrix values.  For example, if \code{m} is of type
\code{matrix[~,~]}, a two-dimensional array of matrices, then
\code{m[1]} refers to the first row of the array, which is a
one-dimensional array of matrices.  More than one index may be used,
so that \code{m[1,2]} is of type \code{matrix} and denotes the matrix
in the first row and second column of the array.  Continuing to add
indices, \code{m[1,2,3]} is of type \code{row\_vector} and denotes
the third row of the matrix denoted by \code{m[1,2]}.  Finally,
\code{m[1,2,3,4]} is of type \code{real} and denotes the value in the
third row and fourth column of the matrix that is found at the first
row and second column of the array \code{m}.

\section{Multiple Indexing and Range Indexing}\label{language-multi-indexing.section}

In addition to single integer indexes, as described in
\refsection{language-indexing}, Stan supports multiple indexing.
Multiple indexes can be integer arrays of indexes, lower
bounds, upper bounds, lower and upper bounds, or simply shorthand for
all of the indexes.  A complete table of index types is given in
\reffigure{index-types}.
%
\begin{figure}[t]
\begin{center}
\begin{tabular}{c|c|c}
{\it index type} & {\it example}  & {\it value} \\ \hline \hline
integer & \code{a[11]} 
& value of \code{a} at index 11
\\ \hline
integer array & \code{a[ii]}
& \code{a[ii[1]]}, \ \ldots, \ \code{a[ii[K]]}
\\[4pt]
lower bound & \code{a[3:]} 
& \code{a[3]}, \ \ldots, \ \code{a[N]}
\\
upper bound & \code{a[:5]}
& \code{a[1]}, \ \ldots, \code{a[5]}
\\
range & \code{a[2:7]}
& \code{a[2]}, \ \ldots, \  \code{a[7]}
\\[4pt]
all & \code{a[:]}
& \code{a[1]}, \ldots, \ \code{a[N]}
\\
all & \code{a[]}
& \code{a[1]}, \ldots, \ \code{a[N]}
\end{tabular}
\end{center}
\vspace*{-8pt}
\caption{\small\it Types of indexes and examples with one-dimensional
  containers of size \code{N} and an integer array \code{ii} of type 
\code{int[]} size \code{K}.}\label{index-types.figure}
\end{figure}

\subsection{Multiple Index Semantics}

The fundamental semantic rule for dealing with multiple indexes is the
following.  If \code{idxs} is a multiple index, then it produces an
indexable position in the result.  To evaluate that index position in
the result, the index is first passed to the multiple index, and the
resulting index used.
%
\begin{stancode}
a[idxs, ...][i, ...] = a[idxs[i], ...][...]
\end{stancode}
%
On the other hand, if \code{idx} is a single index, it reduces the
dimensionality of the output, so that
%
\begin{stancode}
a[idx, ...] = a[idx][...]
\end{stancode}

The only issue is what happens with matrices and vectors.  Vectors
work just like arrays.  Matrices with multiple row indexes and
multiple column indexes produce matrices.  Matrices with multiple row
indexes and a single column index become (column) vectors.  Matrices
with a single row index and multiple column indexes become row
vectors.  The types are summarized in \reffigure{matrix-indexing}.
%
\begin{figure}[t]
\begin{center}
\begin{tabular}{c|c|c|c}
{\it example} & {\it row index} & {\it column index} & {\it result type}
\\ \hline \hline
\code{a[i]} &
single & n/a & row vector
\\
\code{a[is]} &
multiple & n/a & matrix
\\ \hline
\code{a[i, j]} & single & single & real
\\
\code{a[i, js]} & single & multiple & row vector
\\
\code{a[is, j]} & multiple & single & vector
\\
\code{a[is, js]} & multiple & multiple & matrix
\end{tabular}
\end{center}
\caption{\small\it Special rules for reducing matrices based on
  whether the argument is a single or multiple index.  Examples are for
a matrix \code{a}, with integer single indexes \code{i} and \code{j}
and integer array multiple indexes \code{is} and \code{js}.  The same
typing rules apply for all multiple indexes.}%
\label{matrix-indexing.figure} 
\end{figure}

Evaluation of matrices with multiple indexes is defined to respect the
following distributivity conditions.
%
\begin{stancode}
m[idxs1, idxs2][i, j] = m[idxs1[i], idxs2[j]]
m[idxs, idx][j] = m[idxs[j], idx]
m[idx, idxs][j] = m[idx, idxs[j]]
\end{stancode}
%

Evaluation of arrays of matrices and arrays of vectors or row vectors
is defined recursively, beginning with the array dimensions.


\section{Function Application}\label{function-application.section}

Stan provides a range of built in mathematical and statistical
functions, which are documented in \refpart{built-in-functions}.

Expressions in Stan may consist of the name of function followed by a
sequence of zero or more argument expressions.  For instance,
\code{log(2.0)} is the expression of type \code{real} denoting the
result of applying the natural logarithm to the value of the real
literal \code{2.0}.

Syntactically, function application has higher precedence than any of
the other operators, so that \code{y + log(x)} is interpreted as
\code{y + (log(x))}.

\subsection{Type Signatures and Result Type Inference}

Each function has a type signature which determines the allowable type
of its arguments and its return type.  For instance, the function
signature for the logarithm function can be expressed as
%
\begin{quote}
\code{real log(real);}
\end{quote}
%
and the signature for the \code{lmultiply} function is
%
\begin{quote}
\code{real lmultiply(real,real);}
\end{quote}
%
A function is uniquely determined by its name and its sequence of
argument types.  For instance, the following two functions are
different functions.
%
\begin{quote}
\code{real mean(real[]);}
\\
\code{real mean(vector);}
\end{quote}
%
The first applies to a one-dimensional array of real values and the
second to a vector.

The identity conditions for functions explicitly forbids having two
functions with the same name and argument types but different return
types.  This restriction also makes it possible to infer the type of a
function expression compositionally by only examining the type of its
subexpressions.

\subsection{Constants}

Constants in Stan are nothing more than nullary (no-argument)
functions.  For instance, the mathematical constants $\pi$ and $e$ are
represented as nullary functions named \code{pi()} and \code{e()}.
See \refsection{built-in-constants} for a list of built-in constants.

\subsection{Type Promotion and Function Resolution}

Because of integer to real type promotion, rules must be established
for which function is called given a sequence of argument types.  The
scheme employed by Stan is the same as that used by \Cpp, which
resolves a function call to the function requiring the minimum number
of type promotions.

For example, consider a situation in which the following two function
signatures have been registered for \code{foo}.
%
\begin{quote}
\code{real foo(real,real);}
\\
\code{int foo(int,int);}
\end{quote}
%
The use of \code{foo} in the expression \code{foo(1.0,1.0)} resolves
to \code{foo(real,real)}, and thus the expression \code{foo(1.0,1.0)}
itself is assigned a type of \code{real}.

Because integers may be promoted to real values, the expression
\code{foo(1,1)} could potentially match either \code{foo(real,real)}
or \code{foo(int,int)}.  The former requires two type promotions and
the latter requires none, so \code{foo(1,1)} is resolved to function
\code{foo(int,int)} and is thus assigned the type \code{int}.

The expression \code{foo(1,1.0)} has argument types \code{(int,real)}
and thus does not explicitly match either function signature.  By
promoting the integer expression \code{1} to type \code{real}, it is
able to match \code{foo(real,real)}, and hence the type of the
function expression \code{foo(1,1.0)} is \code{real}.

In some cases (though not for any built-in Stan functions), a
situation may arise in which the function referred to by an
expression remains ambiguous.  For example, consider a situation in
which there are exactly two functions named \code{bar} with the
following signatures.
%
\begin{quote}
\code{real bar(real,int);}
\\
\code{real bar(int,real);}
\end{quote}
%
With these signatures, the expression \code{bar(1.0,1)} and
\code{bar(1,1.0)} resolve to the first and second of the above
functions, respectively.  The expression \code{bar(1.0,1.0)} is
illegal because real values may not be demoted to integers.  The
expression \code{bar(1,1)} is illegal for a different reason.  If the
first argument is promoted to a real value, it matches the first
signature, whereas if the second argument is promoted to a real value,
it matches the second signature.  The problem is that these both
require one promotion, so the function name \code{bar} is ambiguous.
If there is not a unique function requiring fewer promotions than all
others, as with \code{bar(1,1)} given the two declarations above,
the Stan compiler will flag the expression as illegal.

\subsection{Random-Number Generating Functions}

For most of the distributions supported by Stan, there is a
corresponding random-number generating function.  These random number
generators are named by the distribution with the suffix \code{\_rng}.
For example, a univariate normal random number can be generated by
\code{normal\_rng(0,1)};  only the parameters of the distribution,
here a location (0) and scale (1) are specified because the variate is
generated.

\subsubsection{Random-Number Generators Locations}

The use of random-number generating functions is restricted to the
transformed data and generated quantities blocks; attempts to use them
elsewhere will result in a parsing error with a diagnostic message.
They may also be used in the bodies of user-defined functions whose
names end in \code{\_rng}.

This allows the random number generating functions to be used for
simulation in general, and for Bayesian posterior predictive checking
in particular.

\subsubsection{Posterior Predictive Checking}

Posterior predictive checks typically use the parameters of the model
to generate simulated data (at the individual and optionally at the
group level for hierarchical models), which can then be compared
informally using plots and formally by means of test statistics, to
the actual data in order to assess the suitability of the model; see
\citep[Chapter~6]{GelmanEtAl:2013} for more information on
posterior predictive checks.

\section{Type Inference}

Stan is strongly statically typed, meaning that the implementation
type of an expression can be resolved at compile time.

\subsection{Implementation Types}

The primitive implementation types for Stan are
%
\code{int},
\code{real},
\code{vector},
\code{row\_vector}, and
\code{matrix}.
%
Every basic declared type corresponds to a primitive type;  see
\reffigure{primitive-type} for the mapping from types to their
primitive types.
%
\begin{figure}
\begin{center}
\begin{tabular}{c|c}
{\it Type} & {\it Primitive Type} \\ \hline \hline
\code{int} & \code{int} \\[6pt]
\code{real} & \code{real} \\[6pt]
\code{matrix} & \code{matrix} \\
\code{cov\_matrix} & \code{matrix} \\
\code{corr\_matrix} & \code{matrix} \\
\code{cholesky\_factor\_cov} & \code{matrix} \\
\code{cholesky\_factor\_corr} & \code{matrix} \\[6pt]
\code{vector} & \code{vector} \\
\code{simplex} & \code{vector} \\
\code{unit\_vector} & \code{vector} \\
\code{ordered} & \code{vector} \\
\code{positive\_ordered} & \code{vector} \\[6pt]
\code{row\_vector} & \code{row\_vector}
\end{tabular}
\end{center}
\caption{\it The table shows the variable declaration types of Stan
  and their corresponding primitive implementation type.  Stan
  functions, operators, and probability functions have argument and
  result types declared in terms of primitive types plus array
  dimensionality.}\label{primitive-type.figure}
\end{figure}
%
A full implementation type consists of a primitive implementation type
and an integer array dimensionality greater than or equal to zero.
These will be written to emphasize their array-like nature.  For
example, \code{int[]} has an array dimensionality of 1, \code{int} an
array dimensionality of 0, and \code{int[~,~,]} an array dimensionality
of 3. The implementation type \code{matrix[~,~,~]} has a total of five
dimensions and takes up to five indices, three from the array and two
from the matrix.

Recall that the array dimensions come before the matrix or vector
dimensions in an expression such as the following declaration of a
three-dimensional array of matrices.
%
\begin{stancode}
matrix[M, N] a[I, J, K];
\end{stancode}
%
The matrix \code{a} is indexed as \code{a[i,~j,~k,~m,~n]} with the array
indices first, followed by the matrix indices, with \code{a[i,~j,~k]}
being a matrix and \code{a[i,~j,~k,~m]} being a row vector.

\subsection{Type Inference Rules}

Stan's type inference rules define the implementation type of an
expression based on a background set of variable declarations.  The
rules work bottom up from primitive literal and variable expressions
to complex expressions.

\subsubsection{Literals}

An integer literal expression such as \code{42} is of type \code{int}.
Real literals such as \code{42.0} are of type \code{real}.

\subsubsection{Variables}

The type of a variable declared locally or in a previous block is
determined by its declaration.  The type of a loop variable is
\code{int}.

There is always a unique declaration for each variable in each scope
because Stan prohibits the redeclaration of an already-declared
variables.%
%
\footnote{Languages such as \Cpp and R allow the declaration of a
  variable of a given name in a narrower scope to hide (take
  precedence over for evaluation) a variable defined in a containing
  scope.}

\subsubsection{Indexing}

If \code{x} is an expression of total dimensionality greater than or
equal to $N$, then the type of expression \code{e[i1,~...,~iN]} is the
same as that of \code{e[i1]...[iN]}, so it suffices to define the type
of a singly-indexed function.  Suppose \code{e} is an expression and
\code{i} is an expression of primitive type \code{int}.  Then
%
\begin{itemize}
\item if \code{e} is an expression of array dimensionality $K > 0$,
  then \code{e[i]} has array dimensionality $K-1$ and the same
  primitive implementation type as \code{e},
%
\item if \code{e} has implementation type \code{vector} or
  \code{row\_vector} of array dimensionality 0, then \code{e[i]} has
  implementation type \code{real}, and
%
\item if \code{e} has implementation type \code{matrix}, then
  \code{e[i]} has type \code{row\_vector}.
\end{itemize}

\subsubsection{Function Application}

If \code{f} is the name of a function and \code{e1,...,eN} are
expressions for $N \geq 0$, then \code{f(e1,...,eN)} is an expression
whose type is determined by the return type in the function signature
for \code{f} given \code{e1} through \code{eN}.  Recall that a
function signature is a declaration of the argument types and the
result type.

In looking up functions, binary operators like \code{real~*~real} are
defined as \code{operator*(real,real)} in the documentation and index.

In matching a function definition, arguments of type \code{int} may be
promoted to type \code{real} if necessary (see the subsection on type
promotion in \refsection{function-application} for an exact
specification of Stan's integer-to-real type-promotion rule).

In general, matrix operations return the lowest inferable type.  For
example, \code{row\_vector~*~vector} returns a value of type
\code{real}, which is declared in the function documentation and index
as \code{real~operator*(row\_vector,vector)}.



\section{Chain Rule and Derivatives}

Derivatives of the log probability function defined by a model are
used in several ways by Stan.  The Hamiltonian Monte Carlo samplers,
including NUTS, use gradients to guide updates.  The BFGS optimizers
also use gradients to guide search for posterior modes.

\subsection{Errors Due to Chain Rule}

Unlike evaluations in pure mathematics, evaluation of derivatives in
Stan is done by applying the chain rule on an expression-by-expression
basis, evaluating using floating-point arithmetic.  As a result,
models such as the following are problematic for inference involving
derivatives.
%
\begin{stancode}
parameters {
  real x;
}
model {
  x ~ normal(sqrt(x - x), 1);
}
\end{stancode}
%
Algebraically, the sampling statement in the model could be reduced to
%
\begin{stancode}
  x ~ normal(0, 1);
\end{stancode}
%
and it would seem the model should produce unit normal samples for
\code{x}.  But rather than canceling, the expression \code{sqrt(x -
  x)} causes a problem for derivatives.  The cause is the mechanistic
evaluation of the chain rule,
%
\begin{eqnarray*}
\frac{d}{dx} \sqrt{x - x}
& = &
\frac{1}{2 \sqrt{x - x}} \times \frac{d}{dx} (x - x)
\\[4pt]
& = &
\frac{1}{0} \times (1 - 1)
\\[4pt]
& = &
\infty \times 0
\\[4pt]
& = & \mbox{NaN}.
\end{eqnarray*}
%
Rather than the $x - x$ canceling out, it introduces a 0 into the
numerator and denominator of the chain-rule evaluation.

The only way to avoid this kind problem is to be careful to do the
necessary algebraic reductions as part of the model and not introduce
expressions like \code{sqrt(x - x)} for which the chain rule produces
not-a-number values.

\subsection{Diagnosing Problems with Derivatives}

The best way to diagnose whether something is going wrong with the
derivatives is to use the test-gradient option to the sampler or
optimizer inputs; this option is available in both Stan and RStan
(though it may be slow, because it relies on finite differences to
make a comparison to the built-in automatic differentiation).

For example, compiling the above model to an executable
\code{sqrt-x-minus-x}, the test can be run as
%
\begin{Verbatim}
> ./sqrt-x-minus-x diagnose test=gradient
\end{Verbatim}
\begin{Verbatim}[fontsize=\small]
...
TEST GRADIENT MODE

 Log probability=-0.393734

 param idx           value           model     finite diff           error
         0       -0.887393             nan               0             nan
\end{Verbatim}
%
Even though finite differences calculates the right gradient of 0,
automatic differentiation follows the chain rule and produces a
not-a-number output.



\chapter{Statements}

\noindent
The blocks of a Stan program (see \refchapter{blocks}) are made up of
variable declarations and statements.  Unlike programs in \BUGS, the
declarations and statements making up a Stan program are executed in
the order in which they are written.  Variables must be defined to
have some value (as well as declared to have some type) before they
are used --- if they do not, the behavior is undefined.

The basis of Stan's execution is the evaluation of a log probability
function (specifically, a probability density function) for a given
set of (real-valued) parameters. Log probability function can be
constructed by using assignment statements.  Statements may be grouped
into sequences and into for-each loops.  In addition, Stan allows
local variables to be declared in blocks and also allows an empty
statement consisting only of a semicolon.


\section{Assignment Statement}\label{assignment-statement.section}

An assignment statement consists of a variable (possibly multivariate
with indexing information) and an expression.  Executing an
assignment statement evaluates the expression on the right-hand side
and assigns it to the (indexed) variable on the left-hand side.  An
example of a simple assignment is as follows.%
%
\footnote{In versions of Stan before 2.15.0, the operator \code{<-} was
  used for assignment rather than using the equal sign \code{=}.  The
  old operator \code{<-} is now deprecated and will print a warning.
  In the future, it will be removed.}
%
\begin{quote}
\code{n = 0;}
\end{quote}
%
Executing this statement assigns the value of the expression \code{0},
which is the integer zero, to the variable \code{n}.  For an assignment
to be well formed, the type of the expression on the right-hand side
should be compatible with the type of the (indexed) variable on the
left-hand side.  For the above example, because \code{0} is an
expression of type \code{int}, the variable \code{n} must be declared
as being of type \code{int} or of type \code{real}.  If the variable
is of type \code{real}, the integer zero is promoted to a
floating-point zero and assigned to the variable.  After the
assignment statement executes, the variable \code{n} will have the
value zero (either as an integer or a floating-point value, depending on
its type).

Syntactically, every assignment statement must be followed by a
semicolon.  Otherwise, whitespace between the tokens does not matter
(the tokens here being the left-hand-side (indexed) variable, the
assignment operator, the right-hand-side expression and the
semicolon).

Because the right-hand side is evaluated first, it is possible to
increment a variable in Stan just as in \Cpp and other programming
languages by writing
%
\begin{quote}
\code{n = n + 1;}
\end{quote}
%
Such self assignments are not allowed in \BUGS, because they induce a
cycle into the directed graphical model.

The left-hand side of an assignment may contain indices for array,
matrix, or vector data structures.  For instance, if \code{Sigma} is
of type \code{matrix}, then
%
\begin{quote}
\code{Sigma[1, 1] = 1.0;}
\end{quote}
%
sets the value in the first column of the first row of \code{Sigma} to one.

Assignments can involve complex objects of any type.  If \code{Sigma}
and \code{Omega} are matrices and \code{sigma} is a vector, then the
following assignment statement, in which the expression and variable
are both of type \code{matrix}, is well formed.
%
\begin{stancode}
Sigma
  = diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
\end{stancode}
%
This example also illustrates the preferred form of splitting a
complex assignment statement and its expression across lines.

Assignments to subcomponents of larger multi-variate data structures
are supported by Stan.  For example, \code{a} is an array of type
\code{real[~,~]} and \code{b} is an array of type \code{real[]}, then
the following two statements are both well-formed.
%
\begin{stancode}
a[3] = b;
b = a[4];
\end{stancode}
%
Similarly, if \code{x} is a variable declared to have type
\code{row\_vector} and \code{Y} is a variable declared as type
\code{matrix}, then the following sequence of statements to swap the
first two rows of \code{Y} is well formed.
%
\begin{stancode}
x = Y[1];
Y[1] = Y[2];
Y[2] = x;
\end{stancode}
%

\subsection{Lvalue Summary}

The expressions that are legal left-hand sides of assignment
statements are known as ``lvalues.''  In Stan, there are only two
kinds of legal lvalues,
%
\begin{itemize}
\item a variable, or
\item a variable with one or more indices.
\end{itemize}
%
To be used as an lvalue, an indexed variable must have at least as
many dimensions as the number of indices provided.  An array of real
or integer types has as many dimensions as it is declared for.  A
matrix has two dimensions and a vector or row vector one dimension;
this also holds for the constrained types, covariance and correlation
matrices and their Cholesky factors and ordered, positive ordered, and
simplex vectors.  An array of matrices has two more dimensions than
the array and an array of vectors or row vectors has one more
dimension than the array.  Note that the number of indices can be less
than the number of dimensions of the variable, meaning that the right
hand side must itself be multidimensional to match the remaining
dimensions.

\subsection{Multiple Indexes}

Multiple indexes, as described in
\refsection{language-multi-indexing}, are also permitted on the
left-hand side of assignments.  Indexing on the left side works
exactly as it does for expressions, with multiple indexes preserving
index positions and single indexes reducing them.    The type on the
left side must still match the type on the right side.

\subsubsection{Aliasing}

All assignment is carried out as if the right-hand side is copied
before the assignment.  This resolves any potential aliasing issues
arising from he right-hand side changing in the middle of an
assignment statement's execution.



\section{Increment Log Density}\label{increment-log-prob.section}

The basis of Stan's execution is the evaluation of a log probability
function (specifically, a probability density function) for a given
set of (real-valued) parameters; this function returns the log density
of the posterior up to an additive constant.  Data and transformed
data are fixed before the log density is evaluated.  The total log
probability is initialized to zero.  Next, any log Jacobian
adjustments accrued by the variable constraints are added to the log
density (the Jacobian adjustment may be skipped for optimization).
Sampling and log probability increment statements may add to the log
density in the model block.  A log probability increment statement
directly increments the log density with the value of an expression as
follows.%
%
\footnote{The current notation replaces two previous versions.
  Originally, a variable \code{lp\_\_} was directly exposed and
  manipulated;  this is no longer allowed.  The original statement
  syntax for \code{target += u} was \code{increment\_log\_prob(u)},
  but this form has been deprecated and will be removed in Stan 3.}
%
\begin{stancode}
target += -0.5 * y * y;
\end{stancode}
%
The keyword \code{target} here is actually not a variable, and may not
be accessed as such (though see below on how to access the value of
target through a special function).

In this example, the unnormalized log probability of a unit normal
variable $y$ is added to the total log probability.  In the general
case, the argument can be any expression.%
%
\footnote{Writing this model with the expression \code{-0.5 * y * y}
  is more efficient than with the equivalent expression \code{y * y /
    -2} because multiplication is more efficient than division; in
  both cases, the negation is rolled into the numeric literal
  (\code{-0.5} and \code{-2}).  Writing \code{square(y)} instead of
  \code{y * y} would be even more efficient because the derivatives
  can be precomputed, reducing the memory and number of operations
  required for automatic differentiation.}

An entire Stan model can be implemented this way.  For instance, the
following model will draw a single variable according to a unit normal
probability.
%
\begin{stancode}
parameters {
  real y;
}
model {
  target += -0.5 * y * y;
}
\end{stancode}
%
This model defines a log probability function
%
\[
\log p(y) = - \, \frac{y^2}{2} - \log Z
\]
%
where $Z$ is a normalizing constant that does not depend on $y$.  The
constant $Z$ is conventionally written this way because on the linear
scale,
\[
p(y) = \frac{1}{Z} \exp\left(-\frac{y^2}{2}\right).
\]
which is typically written without reference to $Z$ as
\[
p(y) \propto \exp\left(-\frac{y^2}{2}\right).
\]

Stan only requires models to be defined up to a constant that does not
depend on the parameters.  This is convenient because often the
normalizing constant $Z$ is either time-consuming to compute or
intractable to evaluate.

\subsubsection{Vectorization}

The \code{target += ...} statement accepts an argument in place of
\code{...} for any expression type, including integers, reals,
vectors, row vectors, matrices, and arrays of any dimensionality,
including arrays of vectors and matrices.   For container arguments,
their sum will be added to the total log density.

\subsection{Accessing the Log Density}

To increment the log density returned by the model by some value
\code{u}, use the following statement.%
%
\footnote{Originally, Stan provided direct access to the log density
  through a variable \code{lp\_\_} and then later through the
  \code{increment\_log\_prob()} statement, but the first has been
  removed and the latter deprecated.}
%
\begin{stancode}
target += u;
\end{stancode}
%
In general, \code{u} can be any expression;  if it is a container, the
log density will be incremented by the sum of the elements in the
container.

To access accumulated log density up to the current execution point,
the function \code{get\_lp()} may be used.%
%
\footnote{The value of \code{lp\_\_} will only hold the Jacobian until
  the end of the execution because it is not used in either
  \code{increment\_log\_prob(u)} or \code{target += u}.}


\section{Sampling Statements}\label{sampling-statements.section}

Stan supports writing probability statements also in sampling
notation, such as
%
\begin{stancode}
y ~ normal(mu,sigma);
\end{stancode}
%
The name ``sampling statement'' is meant to be suggestive, not
interpreted literally.  Conceptually, the variable \code{y}, which may
be an unknown parameter or known, modeled data, is being declared
to have the distribution indicated by the right-hand side of the
sampling statement.

Executing such a statement does not perform any sampling.  In Stan, a
sampling statement is merely a notational convenience.  The above
sampling statement could be expressed as a direct increment on the
total log probability as
%
\begin{stancode}
target += normal_lpdf(y | mu, sigma);
\end{stancode}

In general, a sampling statement of the form
%
\begin{stancode}
y ~ dist(theta1, ..., thetaN);
\end{stancode}
%
involving subexpressions \code{y1} and \code{theta1} through
\code{thetaN} (including the case where \code{N} is zero) will be well
formed if and only if the corresponding assignment statement is
well-formed.  For densities allowing real \code{y} values, the log
probability density function is used,
%
\begin{stancode}
target += dist_lpdf(y | theta1, ..., thetaN);
\end{stancode}
%
For those restricted to integer \code{y} values, the log probability
mass function is used,
%
\begin{stancode}
target += dist_lpmf(y | theta1, ..., thetaN);
\end{stancode}
%

This will be well formed if and only if \code{dist\_lpdf(y | theta1,
  ..., thetaN)} or \code{dist\_lpmf(y | theta1, ..., thetaN)} is a
well-formed expression of type \code{real}.

\subsection{Log Probability Increment vs.\ Sampling Statement}

Although both lead to the same sampling behavior in Stan, there is one
critical difference between using the sampling statement, as in
%
\begin{stancode}
y ~ normal(mu, sigma);
\end{stancode}
%
and explicitly incrementing the log probability function, as in
%
\begin{stancode}
target += normal_lpdf(y | mu,sigma);
\end{stancode}
%
The sampling statement drops all the terms in the log probability
function that are constant, whereas the explicit call to
\code{normal\_lpdf} adds all of the terms in the definition of the log
normal probability function, including all of the constant normalizing
terms.  Therefore, the explicit increment form can be used to recreate
the exact log probability values for the model.  Otherwise, the
sampling statement form will be faster if any of the input expressions,
\code{y}, \code{mu}, or \code{sigma}, involve only constants, data
variables, and transformed data variables.


\subsection{User-Transformed Variables}

The left-hand side of a sampling statement may be a complex
expression.  For instance, it is legal syntactically to write
%
\begin{stancode}
data {
  real<lower=0> y;
}
// ...
model {
  log(y) ~ normal(mu, sigma);
}
\end{stancode}
%
Unfortunately, this is not enough to properly model \code{y} as having
a lognormal distribution.  The log Jacobian of the transform must be
added to the log probability accumulator to account for the
differential change in scale (see \refsection{change-of-variables} for
full definitions).  For the case above, the following adjustment will
account for the log transform.%
%
\footnote{Because $\log | \frac{d}{dy} \log y | = \log | 1/y | = - \log
  |y|$;  see \refsection{change-of-variables}.}
%
\begin{stancode}
target += - log(fabs(y));
\end{stancode}
%

\subsection{Truncated Distributions}

Stan supports truncating distributions with lower bounds, upper
bounds, or both.

\subsubsection{Truncating with lower and upper bounds}

A probability density function $p(x)$ for a continuous distribution
may be truncated to an interval $[a, b]$ to define a new density
$p_{[a, b]}(x)$ with support $[a, b]$ by setting
%
\[
p_{[a, b]}(x)
= \frac{p(x)}
       {\int_a^b p(u) \, du}.
\]
%
A probability mass function $p(x)$ for a discrete distribution may be
truncated to the closed interval $[a, b]$ by
\[
p_{[a, b]}(x) = \frac{p(x)}
                  {\sum_{u = a}^b p(u)}.
\]

\subsubsection{Truncating with a lower bound}

A probability density function $p(x)$ can be truncated to $[a, \infty]$ by
defining
%
\[
p_{[a, \infty]}(x)
= \frac{p(x)}
       {\int_a^{\infty} p(u) \, du}.
\]
%
A probability mass function $p(x)$ is truncated to $[a, \infty]$ by
defining 
%
\[
p_{[a, \infty]}(x) = \frac{p(x)}
                  {\sum_{a <= u} p(u)}.
\]

\subsubsection{Truncating with an upper bound}

A probability density function $p(x)$ can be truncated to $[-\infty, b]$ by
defining
%
\[
p_{[-\infty, b]}(x)
= \frac{p(x)}
       {\int_{-\infty}^b p(u) \, du}.
\]
%
A probability mass function $p(x)$ is truncated to $[-\infty, b]$ by
defining 
%
\[
p_{[-\infty,b]}(x) = \frac{p(x)}
                  {\sum_{u <= b} p(u)}.
\]


\subsubsection{Cumulative distribution functions}

Given a probability function $p_X(x)$ for a random variable $X$, its
cumulative distribution function (cdf) $F_X(x)$ is defined to be the
probability that $X \leq x$,
%
\[
F_X(x) = \mbox{Pr}[X \leq x].
\]
The upper-case variable $X$ is the random variable whereas the
lower-case variable $x$ is just an ordinary bound variable.  For
continuous random variables, the definition of the cdf works out to
\[
F_X(x) \ = \ \int_{-\infty}^{x} p_X(u) \, du,
\]
For discrete variables, the cdf is defined to include the upper bound
given by the argument,
\[
F_X(x) = \sum_{u \leq x} p_X(u).
\]
%

\subsubsection{Complementary cumulative distribution functions}

The complementary cumulative distribution function (ccdf) in both the
continuous and discrete cases is given by
\[
F^C_X(x)
\ = \ \mbox{Pr}[X > x]
\ = \ 1 - F_X(x).
\]
Unlike the cdf, the ccdf is exclusive of the bound, hence the event
$X > x$ rather than the cdf's event $X \leq x$.

For continous distributions, the ccdf works out to 
\[
F^C_X(x)
\ = \ 1 - \int_{-\infty}^x p_X(u) \, du
\ = \ \int_x^{\infty} p_X(u) \, du.
\]
The lower boundary can be included in the integration bounds because
it is a single point on a line and hence has no probability mass.
For the discrete case, the lower bound must be excluded in the
summation explicitly by summing over $u > x$,
\[
F^C_X(x)
\ = \ 1 - \sum_{u \leq x} p_X(u)
\ = \ \sum_{u > x} p_X(u).
\]


Cumulative distribution functions provide the necessary integral
calculations to define truncated distributions.  For truncation with
lower and upper bounds, the denominator is defined by
\[
\int_a^b p(u) \, du = F_X(b) - F_X(a).
\]
This allows truncated distributions to be defined as
\[
p_{[a,b]}(x) = \frac{p_X(x)}
                  {F_X(b) - F_X(a)}.
\]

For discrete distributions, a slightly more complicated form is
required to explicitly insert the lower truncation point, which is
otherwise excluded from $F_X(b) - F_X(a)$,
\[
p_{[a,b]}(x) = \frac{p_X(x)}
                  {F_X(b) - F_X(a) + p_X(a)}.
\]

\subsubsection{Truncation with lower and upper bounds in Stan}

Stan allows probability functions to be truncated.  For example, a
truncated unit normal distributions restricted to $[-0.5, 2.1]$
can be coded with the following sampling statement.
%
\begin{stancode}
y ~ normal(0, 1) T[-0.5, 2.1];
\end{stancode}
%
Truncated distributions are translated as an additional term in the
accumulated log density function plus error checking to make sure the
variate in the sampling statement is within the bounds of the
truncation.

In general, the truncation bounds and parameters may be parameters or
local variables.

Because the example above involves a continuous distribution, it
behaves the same way as the following more verbose form.
%
\begin{stancode}
y ~ normal(0, 1);
if (y < -0.5 || y > 2.1)
  target += negative_infinity();
else
  target += -log_diff_exp(normal_lcdf(2.1 | 0, 1),
                          normal_lcdf(-0.5 | 0, 1));
\end{stancode}
%
Because a Stan program defines a log density function, all
calculations are on the log scale.  The function \code{normal\_lcdf}
is the log of the cumulative normal distribution function and the
function \code{log\_diff\_exp(a, b)} is a more arithmetically stable
form of \code{log(exp(a) - exp(b))}.

For a discrete distribution, another term is necessary in the
denominator to account for the excluded boundary.  The truncated
discrete distribution
%
\begin{stancode}
y ~ poisson(3.7) T[2, 10];
\end{stancode}
%
behaves in the same way as the following code.
%
\begin{stancode}
y ~ poisson(3.7);
if (y < 2 || y > 10) 
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         log_diff_exp(poisson_lcdf(10 | 3.7),
                                      poisson_lcdf(2 | 3.7)));
\end{stancode}
%
Recall that \code{log\_sum\_exp(a, b)} is just the arithmetically
stable form of \code{log(exp(a) + exp(b))}.


\subsubsection{Truncation with lower bounds in Stan}

For truncating with only a lower bound, the upper limit is left blank.
%
\begin{stancode}
y ~ normal(0, 1) T[-0.5, ];
\end{stancode}
%
This truncated sampling statement has the same behavior as the
following code.
%
\begin{stancode}
y ~ normal(0, 1);
if (y < -0.5)
  target += negative_infinity();
else
  target += -normal_lccdf(-0.5 | 0, 1);
\end{stancode}
%
The \code{normal\_lccdf} function is the normal complementary cumulative
distribution function.

As with lower and upper truncation, the discrete case requires a more
complicated denominator to add back in the probability mass for the
lower bound.  Thus
%
\begin{stancode}
y ~ poisson(3.7) T[2, ];
\end{stancode}
%
behaves the same way as
%
\begin{stancode}
y ~ poisson(3.7);
if (y < 2)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         poisson_lccdf(2 | 3.7));
\end{stancode}


\subsubsection{Truncation with upper bounds in Stan}

To truncate with only an upper bound, the lower bound is left blank.  
The upper truncated sampling statement
%
\begin{stancode}
y ~ normal(0, 1) T[ , 2.1];
\end{stancode}
%
produces the same result as the following code.
%
\begin{stancode}
target += normal_lpdf(y | 0, 1);
if (y > 2.1)
  target += negative_infinity();
else 
  target += -normal_lcdf(2.1 | 0, 1);
\end{stancode}

With only an upper bound, the discrete case does not need a boundary
adjustment.  The upper-truncated sampling statement
%
\begin{stancode}
y ~ poisson(3.7) T[ , 10];
\end{stancode}
%
behaves the same way as the following code.
%
\begin{stancode}
y ~ poisson(3.7);
if (y > 10)
  target += negative_infinity();
else 
  target += -poisson_lcdf(10 | 3.7);
\end{stancode}

\subsubsection{Cumulative distributions must be defined}

In all cases, the truncation is only well formed if the appropriate
log density or mass function and necessary log cumulative distribution
functions are defined.  Not every distribution built into Stan has log
cdf and log ccdfs defined, nor will every user-defined distribution.
\refpart{discrete-prob-functions} and
\refpart{continuous-prob-functions} document the available discrete
and continuous cumulative distribution functions; most univariate
distributions have log cdf and log ccdf functions.


\subsubsection{Type constraints on bounds}

For continuous distributions, truncation points must be expressions of
type \code{int} or \code{real}.  For discrete distributions, truncation
points must be expressions of type \code{int}.

\subsubsection{Variates outside of truncation bounds}

For a truncated sampling statement, if the value sampled is not within
the bounds specified by the truncation expression, the result is zero
probability and the entire statement adds $-\infty$ to the total log
probability, which in turn results in the sample being rejected; see
the subsection of \refsection{truncated-data} discussing constraints
and out-of-bounds returns for programming strategies to keep
all values within bounds.

\subsubsection{Vectorizing Truncated Distributions}

Stan does not (yet) support vectorization of distribution functions
with truncation.


\section{For Loops}

Suppose
\code{N} is a variable of type \code{int}, \code{y} is a
one-dimensional array of type \code{real[]}, and \code{mu} and
\code{sigma} are variables of type \code{real}.  Furthermore, suppose
that \code{n} has not been defined as a variable. Then the following
is a well-formed for-loop statement.
%
\begin{stancode}
for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}
\end{stancode}
%
The loop variable is \code{n}, the loop bounds are the values in the
range \code{1:N}, and the body is the statement following the
loop bounds.

\subsection{Loop Variable Typing and Scope}

The bounds in a for loop must be integers.  Unlike in \R, the loop is
always interpreted as an upward counting loop.  The range \code{L:H}
will cause the loop to execute the loop with the loop variable taking
on all integer values greater than or equal to \code{L} and less than
or equal to \code{H}.  For example, the loop \code{for (n in 2:5)}
will cause the body of the for loop to be executed with \code{n} equal
to 2, 3, 4, and 5, in order.  The variable and bound \code{for (n in
  5:2)} will not execute anything because there are no integers
greater than or equal to 5 and less than or equal to 2.

\subsection{Order Sensitivity and Repeated Variables}

Unlike in \BUGS, Stan allows variables to be reassigned.  For
example, the variable \code{theta} in the following program is
reassigned in each iteration of the loop.
%
\begin{stancode}
for (n in 1:N) {
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}
\end{stancode}
%
Such reassignment is not permitted in \BUGS.  In \BUGS, for loops are
declarative, defining plates in directed graphical model notation,
which can be thought of as repeated substructures in the graphical
model.  Therefore, it is illegal in \BUGS or \JAGS to have a for loop
that repeatedly reassigns a value to a variable.%
%
\footnote{A programming idiom in \BUGS code simulates
a local variable by replacing \code{theta} in the above example with
\code{theta[n]}, effectively creating \code{N} different variables,
\code{theta[1]}, \ldots, \code{theta[N]}.  Of course, this is not a
hack if the value of \code{theta[n]} is required for all \code{n}.}

In Stan, assignments are executed in the order they are encountered.
As a consequence, the following Stan program has a very different
interpretation than the previous one.
%
\begin{stancode}
for (n in 1:N) {
  y[n] ~ bernoulli(theta);
  theta = inv_logit(alpha + x[n] * beta);
}
\end{stancode}
%
In this program, \code{theta} is assigned after it is used in the
probability statement.  This presupposes it was defined before the
first loop iteration (otherwise behavior is undefined), and then each
loop uses the assignment from the previous iteration.

Stan loops may be used to accumulate values.  Thus it is possible to
sum the values of an array directly using code such as the
following.
%
\begin{stancode}
total = 0.0;
for (n in 1:N)
  total = total + x[n];
\end{stancode}
%
After the for loop is executed, the variable \code{total} will hold
the sum of the elements in the array \code{x}.  This example was
purely pedagogical; it is easier and more efficient to write
%
\begin{stancode}
total = sum(x);
\end{stancode}

A variable inside (or outside) a loop may even be reassigned multiple
times, as in the following legal code.
%
\begin{stancode}
for (n in 1:100) {
  y = y + y * epsilon;
  epsilon = epsilon / 2.0;
  y = y + y * epsilon;
}
\end{stancode}

\section{Conditional Statements}

Stan supports full conditional statements using
the same if-then-else syntax as \Cpp.  The general format is
%
\begin{stancode}
if (condition1)
  statement1
else if (condition2)
  statement2
// ...
else if (conditionN-1)
  statementN-1
else
  statementN
\end{stancode}
%
There must be a single leading \code{if} clause, which may be followed
by any number of \code{else if} clauses, all of which may be
optionally followed by an \code{else} clause.  Each condition must be
a real or integer value, with non-zero values interpreted as true and
the zero value as false.

The entire sequence of if-then-else clauses forms a single conditional
statement for evaluation.  The conditions are evaluated in order
until one of the conditions evaluates to a non-zero value, at which
point its corresponding statement is executed and the conditional
statement finishes execution.  If none of the conditions evaluates to
a non-zero value and there is a final else clause, its statement is
executed.

\section{While Statements}

Stan supports standard while loops using the same syntax as \Cpp.  The
general format is as follows.
%
\begin{stancode}
while (condition)
  body
\end{stancode}
%
The condition must be an integer or real expression and the body can
be any statement (or sequence of statements in curly braces).

Evaluation of a while loop starts by evaluating the condition.  If the
condition evaluates to a false (zero) value, the execution of the loop
terminates and control moves to the position after the loop.  If the
loop's condition evaluates to a true (non-zero) value, the body statement is
executed, then the whole loop is executed again.  Thus the loop is
continually executed as long as the condition evaluates to a true value.


\section{Statement Blocks and Local Variable Declarations}

Just as parentheses may be used to group expressions, curly brackets
may be used to group a sequence of zero or more statements into a
statement block.  At the beginning of each block, local variables may be
declared that are scoped over the rest of the statements in the block.

\subsection{Blocks in For Loops}

Blocks are often used to group a sequence of statements together to be
used in the body of a for loop.  Because the body of a for loop can be
any statement, for loops with bodies consisting of a single statement
can be written as follows.
%
\begin{stancode}
for (n in 1:N)
  y[n] ~ normal(mu,sigma);
\end{stancode}
%
To put multiple statements inside the body of a for loop, a block is
used, as in the following example.
%
\begin{stancode}
for (n in 1:N) {
  lambda[n] ~ gamma(alpha,beta);
  y[n] ~ poisson(lambda[n]);
}
\end{stancode}
%
The open curly bracket (\code{\{}) is the first character of the block
and the close curly bracket (\code{\}}) is the last character.

Because whitespace is ignored in Stan, the following program will
not compile.
%
\begin{stancode}
for (n in 1:N)
  y[n] ~ normal(mu, sigma);
  z[n] ~ normal(mu, sigma); // ERROR!
\end{stancode}
%
The problem is that the body of the for loop is taken to be the
statement directly following it, which is
\Verb|y[n] ~ normal(mu,sigma)|.  This leaves the probability statement for
\code{z[n]} hanging, as is clear from the following equivalent
program.
%
\begin{stancode}
for (n in 1:N) {
  y[n] ~ normal(mu, sigma);
}
z[n] ~ normal(mu, sigma); // ERROR!
\end{stancode}
%
Neither of these programs will compile. If the loop variable \code{n}
was defined before the for loop, the for-loop declaration will raise
an error.  If the loop variable \code{n} was not defined before the
for loop, then the use of the expression \code{z[n]} will raise an
error.

\subsection{Local Variable Declarations}

A for loop has a statement as a body.  It is often convenient in
writing programs to be able to define a local variable that will be
used temporarily and then forgotten.  For instance, the for loop
example of repeated assignment should use a local variable for maximum
clarity and efficiency, as in the following example.
%
\begin{stancode}
for (n in 1:N) {
  real theta;
  theta = inv_logit(alpha + x[n] * beta);
  y[n] ~ bernoulli(theta);
}
\end{stancode}
%
The local variable \code{theta} is declared here inside the for loop.
The scope of a local variable is just the block in which it is
defined.  Thus \code{theta} is available for use inside the for loop,
but not outside of it.  As in other situations, Stan does not allow
variable hiding.  So it is illegal to declare a local variable
\code{theta} if the variable theta is already defined in the scope of
the for loop.  For instance, the following is not legal.
%
\begin{stancode}
for (m in 1:M) {
  real theta;
  for (n in 1:N) {
    real theta; // ERROR!
    theta = inv_logit(alpha + x[m, n] * beta);
    y[m, n] ~ bernoulli(theta);
// ...
\end{stancode}
%
The compiler will flag the second declaration of \code{theta} with a
message that it is already defined.

\subsection{No Constraints on Local Variables}

Local variables may not have constraints on their declaration.  The
only types that may be used are
%
\begin{quote}
\code{int}, \code{real},
\code{vector[K]}, \code{row\_vector[K]}, and \code{matrix[M, N]}.
\end{quote}

\subsection{Blocks within Blocks}

A block is itself a statement, so anywhere a sequence of statements is
allowed, one or more of the statements may be a block.  For instance,
in a for loop, it is legal to have the following
%
\begin{stancode}
for (m in 1:M) {
  {
     int n;
     n = 2 * m;
     sum = sum + n
  }
  for (n in 1:N)
    sum = sum + x[m, n];
}
\end{stancode}
%
The variable declaration \code{int n;} is the first element of an
embedded block and so has scope within that block.  The for loop
defines its own local block implicitly over the statement following it
in which the loop variable is defined.  As far as Stan is concerned,
these two uses of \code{n} are unrelated.

\section{Break and Continue Statements}

The one-token statements \code{continue} and \code{break} may be used
within loops to alter control flow;  \code{continue} causes the next
iteration of the loop to run immediately, whereas \code{break}
terminates the loop and causes execution to resume after the loop.
Both control structures must appear in loops.  Both \code{break} and
\code{continue} scope to the most deeply nested loop, but pass through
non-loop statements.

Although these control statements may seem undesirable because of
their goto-like behavior, their judicious use can greatly improve
readability by reducing the level of nesting or eliminating bookkeeping
inside loops.

\subsection{Break Statements}

When a \code{break} statement is executed, the most deeply nested loop
currently being executed is ended and execution picks up with the next
statement after the loop.  For example, consider the following
program:
%
\begin{stancode}
while (1) {
  if (n < 0) break;
  foo(n);
  n = n - 1;
}
\end{stancode}
%
The \code{while~(1)} loop is a ``forever'' loop, because \code{1} is
the true value, so the test always succeeds.  Within the loop, if the
value of \code{n} is less than 0, the loop terminates, otherwise it
executes \code{foo(n)} and then decrements \code{n}.  The statement
above does exactly the same thing as
%
\begin{stancode}
while (n >= 0) {
  foo(n);
  n = n - 1;
}
\end{stancode}
%
This case is simply illustrative of the behavior; it is not a case
where a \code{break} simplifies the loop.

\subsection{Continue Statements}

The \code{continue} statement ends the current operation of the loop
and returns to the condition at the top of the loop.  Such loops are
typically used to exclude some values from calculations.  For example,
we could use the following loop to sum the positive values in the
array \code{x},
%
\begin{stancode}
real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] <= 0) continue;
  sum = sum + x[n];
}
\end{stancode}
%
When the continue statement is executed, control jumps back to the
conditional part of the loop.  With while and for loops, this causes
control to return to the conditional of the loop.  With for loops,
this advances the loop variable, so the the above program will not go
into an infinite loop when faced with an \code{x[n]} less than zero.
Thus the above program could be rewritten with deeper nesting by
reversing the conditional,
%
\begin{stancode}
real sum;
sum = 0;
for (n in 1:size(x)) {
  if (x[n] > 0)
    sum = sum + x[n];
}
\end{stancode}
%
While the latter form may seem more readable in this simple case, the
former has the main line of execution nested one level less deep.
Instead, the conditional at the top finds cases to exclude and doesn't
require the same level of nesting for code that's not excluded.  When
there are several such exclusion conditions, the break or continue
versions tend to be much easier to read.

\subsection{Breaking and Continuing Nested Loops}

If there is a loop nested within a loop, a \code{break} or
\code{continue} statement only breaks out of the inner loop. So
%
\begin{stancode}
while (cond1) {
  ...
  while (cond2) {
    ...
    if (cond3) break;
    ...
  }
  // execution continues here after break
  ...
}
\end{stancode}
%
If the break is triggered by \code{cond3} being true, execution will
continue after the nested loop.

As with break statements, continue statements go back to the top of
the most deeply nested loop in which the \code{continue} appears.  

Although break and continue must appear within loops, they may appear
in nested statements within loops, such as within the conditionals
shown above or within nested statements.  The break and continue
statements jump past any control structure other than while-loops and
for-loops.

\section{Print Statements}\label{print-statements.section}

Stan provides print statements that can print literal strings and the
values of expressions.  Print statements accept any number of
arguments.  Consider the following for-each statement with a print
statement in its body.
%
\begin{stancode}
for (n in 1:N) { print("loop iteration: ", n); ... }
\end{stancode}
%
The print statement will execute every time the body of the loop does.
Each time the loop body is executed, it will print the string ``loop iteration:
'' (with the trailing space), followed by the value of the expression
\code{n}, followed by a new line.

\subsection{Print Content}

The text printed by a print statement varies based on its content.  A
literal (i.e., quoted) string in a print statement always prints
exactly that string (without the quotes).  Expressions in print
statements result in the value of the expression being printed.
But how the value of the expression is formatted will depend on its type.

Printing a simple \code{real} or \code{int} typed variable always
prints the variable's value.%
%
\footnote{The adjoint component is always zero during execution for
  the algorithmic differentiation variables used to implement
  parameters, transformed parameters, and local variables in the model.}
%
For array, vector, and matrix variables, the print format uses
brackets.  For example, a 3-vector will print as
%
\begin{stancode}
[1, 2, 3]
\end{stancode}
%
and a $2 \times 3$-matrix as
%
\begin{stancode}
[[1, 2, 3], [4, 5, 6]]
\end{stancode}
%

Printing a more readable version of arrays or matrices can be done
with loops.  An example is the print statement in the following
transformed data block.
%
\begin{stancode}
transformed data {
  matrix[2, 2] u;
  u[1, 1] = 1.0;   u[1, 2] = 4.0;
  u[2, 1] = 9.0;   u[2, 2] = 16.0;
  for (n in 1:2)
    print("u[", n, "] = ", u[n]);
}
\end{stancode}
%
This print statement executes twice, printing the following two lines
of output.
%
\begin{stancode}
u[1] = [1, 4]
u[2] = [9, 16]
\end{stancode}

\subsection{Non-void Input}

The input type to a print function cannot be void.  In particular, it
can't be the result of a user-defined void function.  All other types
are allowed as arguments to the print function.

\subsection{Print Frequency}

Printing for a print statement happens every time it is executed.  The
\code{transformed data} block is executed once per chain, the
\code{transformed parameter} and \code{model} blocks once per leapfrog
step, and the \code{generated quantities} block once per iteration.

\subsection{String Literals}

String literals begin and end with a double quote character
(\Verb|"|).  The characters between the double quote characters may be
the space character or any visible ASCII character, with the exception
of the backslash character (\Verb|\|) and double quote character
(\Verb|"|).  The full list of visible ASCII characters is as follows.
%
\begin{quote}
\begin{Verbatim}
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9 0 ~ @ # $ % ^ & * _ ' ` - + = {
} [ ] ( ) < > | / ! ? . , ; :
\end{Verbatim}
\end{quote}
%$ to fix AUXTeX highlighting

\subsection{Debug by \code{print}}

Because Stan is an imperative language, print statements can be very
useful for debugging.  They can be used to display the values of
variables or expressions at various points in the execution of a
program.  They are particularly useful for spotting problematic
not-a-number of infinite values, both of which will be printed.

It is particularly useful to print the value of the log probability
accumulator (see \refsection{get-lp}), as in the following example.
%
\begin{stancode}
vector[2] y;
y[1] = 1;
print("lp before =", target());
y ~ normal(0,1);  // bug!  y[2] not defined
print("lp after =", target());
\end{stancode}
%
The example has a bug in that \code{y[2]} is not defined before the
vector \code{y} is used in the sampling statement.  By printing the
value of the log probability accumulator before and after each
sampling statement, it's possible to isolate where the log probability
becomes ill-defined (i.e., becomes not-a-number).

\section{Reject Statements}\label{reject-statements.section}

The Stan \code{reject} statement provides a mechanism to
report errors or problematic values encountered during program
execution and either halt processing or reject samples or optimization
iterations.

Like the \code{print} statement, the reject statement accepts
any number of quoted string literals or Stan expressions as arguments.

Reject statements are typically embedded in a conditional
statement in order to detect variables in illegal states.  For
example, the following code handles the case where a variable \code{x}'s
value is negative.
%
\begin{stancode}
if (x < 0)
  reject("x must not be negative; found x=", x);
\end{stancode}

\subsection{Behavior of Reject Statements}

Reject statements have the same behavior as exceptions thrown by
built-in Stan functions.  For example, the \code{normal\_lpdf} function
raises an exception if the input scale is not positive and finite.
The effect of a reject statement depends on the program block in which
the rejection occurs.

In all cases of rejection, the interface accessing the Stan
program should print the arguments to the reject statement.

\subsubsection{Rejections in Functions}

Rejections in user-defined functions are just passed to the
calling function or program block.  Reject statements can be used in
functions to validate the function arguments, allowing user-defined
functions to fully emulate built-in function behavior.  It is better
to find out earlier rather than later when there is a problem.

\subsubsection{Fatal Exception Contexts}

In both the transformed data block and generated quantities block,
rejections are fatal.  This is because if initialization fails or if
generating output fails, there is no way to recover values.

Reject statements placed in the transformed data block can be used
to validate both the data and transformed data (if any).  This allows
more complicated constraints to be enforced that can be specified with
Stan's constrained variable declarations.


\subsubsection{Recoverable Rejection Contexts}

Rejections in the transformed parameters and model blocks are
not in and of themselves instantly fatal.  The result has the same
effect as assigning a $-\infty$ log probability, which causes
rejection of the current proposal in MCMC samplers and adjustment of
search parameters in optimization.

If the log probability function results in a rejection every time it is
called, the containing application (MCMC sampler or optimization)
should diagnose this problem and terminate with an appropriate error
message.  To aid in diagnosing problems, the message for each
reject statement will be printed as a result of executing it.


\subsection{Rejection is not for Constraints}

Rejection should be used for error handling, not defining arbitrary
constraints.  Consider the following errorful Stan program.
%
\begin{stancode}
parameters {
  real a;
  real<lower=a> b;
  real<lower=a, upper=b> theta;
  ...
model {
  // **wrong** needs explicit truncation
  theta ~ normal(0, 1); 
  ...
\end{stancode}
%
This program is wrong because its truncation bounds on \code{theta}
depend on parameters, and thus need to be accounted for using an
explicit truncation on the distribution.  This is the right way to do
it.  
%
\begin{stancode}
  theta ~ normal(0, 1) T[a, b];
\end{stancode}
%
The conceptual issue is that the prior does not integrate to one over
the admissible parameter space; it integrates to one over all real
numbers and integrates to something less than one over $[a ,b]$; in
these simple univariate cases, we can overcome that with the
\code{T[~,~]} notation, which essentially divides by whatever the
prior integrates to over $[a, b]$.

This problem is exactly the same problem as you would get using reject
statements to enforce complicated inequalities on multivariate
functions.  In this case, it is wrong to try to deal with truncation
through constraints.
%
\begin{stancode}
  if (theta < a || theta > b)
    reject("theta not in (a, b)");
  // still **wrong**, needs T[a,b]
  theta ~ normal(0, 1);
\end{stancode} 
%
In this case, the prior integrates to something less than one over the
region of the parameter space where the complicated inequalities are
satisfied. But we don't generally know what value the prior integrates
to, so we can't increment the log probability function to compensate.

Even if this adjustment to a proper probability model may seem like
``no big deal'' in particular models where the amount of truncated
posterior density is negligible or constant, we can't sample from that
truncated posterior efficiently.  Programs need to use one-to-one
mappings that guarantee the constraints are satisfied and only use
reject statements to raise errors or help with debugging.



\chapter{Program Blocks}\label{blocks.chapter}

\noindent
A Stan program is organized into a sequence of named blocks, the
bodies of which consist of variable declarations, followed in the case
of some blocks with statements.

\section{Comments}\label{comments.section}

Stan supports \Cpp-style line-based and bracketed comments.  Comments
may be used anywhere whitespace is allowed in a Stan program.

\subsection{Line-Based Comments}

In line-based comments, any text on a line following
two forward slashes (\Verb|//|) or the pound sign (\Verb|#|)
is ignored (along with the slashes or pound sign).

\subsection{Bracketed Comments}

For bracketed comments, any text between a forward-slash and asterisk
pair (\Verb|/*|) and an asterisk and forward-slash pair (\Verb|*/|) is
ignored.

\subsection{Character Encoding}

Comments may be in ASCII, UTF-8, Latin1, or any other character
encoding that is byte-wise compatible with ASCII.  This excludes
encodings like UTF-16, Big5, etc.%
%
\footnote{The issue is that they will separate the characters in
  \code{*/} and \code{*/}.}


\section{Overview of Stan's Program Blocks}

The full set of named program blocks is exemplified in the following
skeletal Stan program.
%
\begin{stancode}
functions {
  // ... function declarations and definitions ...
}
data {
  // ... declarations ...
}
transformed data {
   // ... declarations ... statements ...
}
parameters {
   // ... declarations ...
}
transformed parameters {
   // ... declarations ... statements ...
}
model {
   // ... declarations ... statements ...
}
generated quantities {
   // ... declarations ... statements ...
}
\end{stancode}
%
The function-definition block contains user-defined functions.  The
data block declares the required data for the model.  The transformed
data block allows the definition of constants and transforms of the
data.  The parameters block declares the model's parameters --- the
unconstrained version of the parameters is what's sampled or
optimized.  The transformed parameters block allows variables to be
defined in terms of data and parameters that may be used later and
will be saved.  The model block is where the log probability function
is defined.  The generated quantities block allows derived quantities
based on parameters, data, and optionally (pseudo) random number
generation.


\subsection{Optionality and Ordering}

All of the blocks are optional.  A consequence of this is that the
empty string is a valid Stan program, although it will trigger a
warning message from the Stan compiler.  The Stan program blocks
that occur must occur in the order presented in the skeletal program
above.  Within each block, both declarations and statements are
optional, subject to the  restriction that the declarations come
before the statements.

\subsection{Variable Scope}

The variables declared in each block have scope over all subsequent
statements.  Thus a variable declared in the transformed data block
may be used in the model block.  But a variable declared in the
generated quantities block may not be used in any earlier block,
including the model block.  The exception to this rule is that
variables declared in the model block are always local to the model
block and may not be accessed in the generated quantities block; to
make a variable accessible in the model and generated quantities
block, it must be declared as a transformed parameter.

Variables declared as function parameters have scope only within that
function definition's body, and may not be assigned to (they are
constant).

\subsection{Function Scope}

Functions defined in the function block may be used in any appropriate
block.  Most functions can be used in any block and applied to a
mixture of parameters and data (including constants or program
literals).

Random-number-generating functions are restricted to the generated
quantities block; such functions are suffixed with \code{\_rng}.
Log-probability modifying functions to blocks where the log
probability accumulator is in scope (transformed parameters and
model); such functions are suffixed with \code{\_lp}.

Density functions defined in the program may be used in sampling
statements.

\subsection{Automatic Variable Definitions}

The variables declared in the \code{data} and \code{parameters} block
are treated differently than other variables in that they are
automatically defined by the context in which they are used.  This is
why there are no statements allowed in the data or parameters block.

The variables in the \code{data} block are read from an external input
source such as a file or a designated \R data structure.  The
variables in the \code{parameters} block are read from the sampler's
current parameter values (either standard \HMC or \NUTS).  The initial
values may be provided through an external input source, which is also
typically a file or a designated \R data structure.  In each case, the
parameters are instantiated to the values for which the model defines
a log probability function.

\subsection{Transformed Variables}

The \code{transformed data} and \code{transformed parameters} block
behave similarly to each other.  Both allow new variables to be
declared and then defined through a sequence of statements.  Because
variables scope over every statement that follows them, transformed
data variables may be defined in terms of the data variables.

Before generating any samples, data variables are read in, then the
transformed data variables are declared and the associated statements
executed to define them.  This means the statements in the transformed
data block are only ever evaluated once.%
%
\footnote{If the \Cpp code is configured for concurrent threads, the
  data and transformed data blocks can be executed once and reused for
  multiple chains.}
%
Transformed parameters work the same way, being defined in terms of
the parameters, transformed data, and data variables.  The difference
is the frequency of evaluation.  Parameters are read in and (inverse)
transformed to constrained representations on their natural scales
once per log probability and gradient evaluation.  This means the
inverse transforms and their log absolute Jacobian determinants are
evaluated once per leapfrog step.  Transformed parameters are then
declared and their defining statements executed once per leapfrog
step.

\subsection{Generated Quantities}

The generated quantity variables are defined once per sample after all
the leapfrog steps have been completed.  These may be random
quantities, so the block must be rerun even if the Metropolis
adjustment of \HMC or \NUTS rejects the update proposal.


\subsection{Variable Read, Write, and Definition Summary}

A table summarizing the point at which variables are read, written, and
defined is given in \reffigure{block-actions}.
%
\begin{figure}
\begin{center}
\begin{tabular}{l|c|l}
{\it Block} & {\it Stmt} & {\it Action / Period}
\\\hline\hline
\code{data} & no & read / chain
\\
\code{transformed data} & yes & evaluate / chain
\\ \hline
\code{parameters} & no & inv.\ transform, Jacobian / leapfrog  \\
& & inv.\ transform, write / sample
\\[3pt]
\code{transformed parameters} & yes & evaluate / leapfrog \\
& & write / sample
\\\hline
\code{model} & yes & evaluate / leapfrog step
\\\hline
\code{generated quantities} & yes & eval / sample \\
& & write / sample
\\\hline\hline
\code{\slshape (initialization)} & n/a & read, transform / chain
\end{tabular}
\end{center}
\caption{\it The read, write, transform, and evaluate actions and
  periodicities listed in the last column correspond to the Stan
  program blocks in the first column.  The middle column indicates
  whether the block allows statements.  The last row indicates that
  parameter initialization requires a read and transform operation
  applied once per chain.}%
\label{block-actions.figure}
\end{figure}
%
\begin{figure}[t]
\begin{center}
\begin{tabular}{ccc|l}
{\it Params} & {\it Log Prob} & {\it Print} & {\it Declare In}
\\\hline \hline
$+$ & $+$ & $+$ & \code{transformed parameters}
\\
$+$ & $+$ & $-$ & {\it local in}\ \code{model}
\\
$+$ & $-$ & $-$ & {\it local in}\ \code{generated quantities}
\\
$+$ & $-$ & $+$ & \code{generated quantities}
\\
$-$ & $-$ & $+$ & \code{generated quantities}$^*$
\\
$-$ & $\pm$ & $-$ & {\it local in}\ \code{transformed data}
\\
$-$ & $+$ & $+$ & \code{transformed data} {\it and}\ \code{generated quantities}$^*$
\end{tabular}
\end{center}
\caption{\it This table indicates where variables that are not basic
  data or parameters should be declared, based on whether it is
  defined in terms of parameters, whether it is used in the log
  probability function defined in the model block, and whether it is
  printed.  The two lines marked with asterisks ($*$) should not be
  used as there is no need to print a variable every iteration that
  does not depend on the value of any parameters (for information on
  how to print these if necessary, see \refnote{print-var-no-param}
  in this chapter).}%
\label{variable-flowchart.figure}
\end{figure}
%
Another way to look at the variables is in terms of their function.
To decide which variable to use, consult the charts in
\reffigure{variable-flowchart}.  The last line has no
corresponding location, as there is no need to print a variable
every iteration that does not depend on parameters.%
%
\footnote{It is possible to print a variable every iteration that does
  not depend on parameters --- just define it (or redefine it if it is
  transformed data) in the \code{generated quantities} block.\label{print-var-no-param.footnote}}
%
The rest of this chapter provides full details on when and how the
variables and statements in each block are executed.
%


\section{Statistical Variable Taxonomy}

%
\begin{figure}
\begin{center}
\begin{tabular}{l|l}
{\it Variable Kind} & {\it Declaration Block}
\\ \hline\hline
% constants & \code{transformed data}
% \\ \hline
unmodeled data & \code{data}, \code{transformed data}
\\
modeled data & \code{data}, \code{transformed data}
\\ \hline
missing data & \code{parameters}, \code{transformed parameters}
\\
modeled parameters & \code{parameters}, \code{transformed parameters}
\\
unmodeled parameters & \code{data}, \code{transformed data}
\\[2pt] \hline
generated quantities & \code{transformed data}, \code{transformed parameters},
\\
& \code{generated quantities}
\\ \hline\hline
loop indices & loop statement
\\
\end{tabular}
\end{center}
\caption{\it Variables of the kind indicated in the left column must
 be declared in one of the blocks declared in the right
 column.}\label{variable-kinds.figure}
\end{figure}
%
\cite[p.~366]{GelmanHill:2007} provides a taxonomy of the kinds of
variables used in Bayesian models.  \reffigure{variable-kinds} contains
Gelman and Hill's taxonomy along with a missing-data kind along with
the corresponding locations of declarations and definitions in Stan.

Constants can be built into a model as literals, data variables, or
as transformed data variables.  If specified as variables, their
definition must be included in data files.  If they are specified as
transformed data variables, they cannot be used to specify the sizes
of elements in the \code{data} block.

The following program illustrates various variables kinds, listing the
kind of each variable next to its declaration.
%
\begin{stancode}
data {
  int<lower=0> N;           // unmodeled data
  real y[N];                // modeled data
  real mu_mu;               // config. unmodeled param
  real<lower=0> sigma_mu;   // config. unmodeled param
}
transformed data {
  real<lower=0> alpha;      // const. unmodeled param
  real<lower=0> beta;       // const. unmodeled param
  alpha = 0.1;
  beta = 0.1;
}
parameters {
  real mu_y;                // modeled param
  real<lower=0> tau_y;      // modeled param
}
transformed parameters {
  real<lower=0> sigma_y;    // derived quantity (param)
  sigma_y = pow(tau_y, -0.5);
}
model {
  tau_y ~ gamma(alpha, beta);
  mu_y ~ normal(mu_mu, sigma_mu);
  for (n in 1:N)
    y[n] ~ normal(mu_y, sigma_y);
}
generated quantities {
  real variance_y;       // derived quantity (transform)
  variance_y = sigma_y * sigma_y;
}
\end{stancode}
%  from generated_quantities
%  for (n in 1:N)
%    y_variance[n] = sigma_y rand_normal(mu_y,sigma_y);
%
In this example, \code{y[N]} is a modeled data vector.  Although it is
specified in the \code{data} block, and thus must have a known value
before the program may be run, it is modeled as if it were generated
randomly as described by the model.

The variable \code{N} is a typical example of unmodeled data.  It is
used to indicate a size that is not part of the model itself.

The other variables declared in the data and transformed data block are
examples of unmodeled parameters, also known as hyperparameters.
Unmodeled parameters are parameters to probability densities that are
not themselves modeled probabilistically.  In Stan, unmodeled
parameters that appear in the \code{data} block may be specified on a
per-model execution basis as part of the data read.  In the above
model, \code{mu\_mu} and \code{sigma\_mu} are configurable unmodeled
parameters.

Unmodeled parameters that are hard coded in the model must be declared
in the \code{transformed data} block.  For example, the unmodeled
parameters \code{alpha} and \code{beta} are both hard coded to the
value 0.1.  To allow such variables to be configurable based on data
supplied to the program at run time, they must be declared in the
\code{data} block, like the variables \code{mu\_mu} and
\code{sigma\_mu}.

This program declares two modeled parameters, \code{mu} and
\code{tau\_y}.  These are the location and precision used in the normal
model of the values in \code{y}.  The heart of the model will be
sampling the values of these parameters from their posterior
distribution.

The modeled parameter \code{tau\_y} is transformed from a precision to
a scale parameter and assigned to the variable \code{sigma\_y} in the
\code{transformed parameters} block. Thus the variable \code{sigma\_y}
is considered a derived quantity --- its value is entirely determined
by the values of other variables.

The \code{generated quantities} block defines a value
\code{variance\_y}, which is defined as a transform of the scale or
deviation parameter \code{sigma\_y}.  It is defined in the generated
quantities block because it is not used in the model.  Making it
a generated quantity allows it to be monitored for convergence (being
a non-linear transform, it will have different autocorrelation and
hence convergence properties than the deviation itself).

In later versions of Stan which have random number generators for
the distributions, the \code{generated quantities} block will be
usable to generate replicated data for model checking.

Finally, the variable \code{n} is used as a loop index in the
\code{model} block.


\section{Program Block: \code{data}}

The rest of this chapter will lay out the details of each block in
order, starting with the \code{data} block in this section.

\subsection{Variable Reads and Transformations}

The \code{data} block is for the declaration of variables that are
read in as data.  With the current model executable, each Markov chain
of samples will be executed in a different process, and each such
process will read the data exactly once.%
%
\footnote{With multiple threads, or even running chains sequentially
  in a single thread, data could be read only once per set of
  chains. Stan was designed to be thread safe and future versions
  will provide a multithreading option for Markov chains.\label{thread.footnote}}
%

Data variables are not transformed in any way.  The format for data
files or data in memory depends on the interface; see the user's
guides and interface documentation for PyStan, RStan, and CmdStan for details.

\subsection{Statements}

The \code{data} block does not allow statements.

\subsection{Variable Constraint Checking}

Each variable's value is validated against its declaration as it is
read.  For example, if a variable \code{sigma} is declared as
\code{real<lower=0>}, then trying to assign it a negative value will raise
an error.  As a result, data type errors will be caught as early as
possible.  Similarly, attempts to provide data of the wrong size for a
compound data structure will also raise an error.


\section{Program Block: \code{transformed data}}

The \code{transformed data} block is for declaring and defining
variables that do not need to be changed when running the program.

\subsection{Variable Reads and Transformations}

For the \code{transformed data} block, variables are all declared in
the variable declarations and defined in the statements.  There is no
reading from external sources and no transformations performed.

Variables declared in the \code{data} block may be used to declare
transformed variables.

\subsection{Statements}

The statements in a \code{transformed data} block are used to define
(provide values for) variables declared in the \code{transformed data}
block. Assignments are only allowed to variables declared in the
\code{transformed data} block.

These statements are executed once, in order, right after the data is
read into the data variables.  This means they are executed once per
chain (though see \refnote{thread} in this chapter).

Variables declared in the \code{data} block may be used in statements
in the \code{transformed data} block.

\subsubsection{Restriction on Operations in \code{transformed data}}

The statements in the transformed data block are designed to be
executed once and have a deterministic result.  Therefore, log
probability is not accumulated and sampling statements may not be
used.  Random number generating functions are also prohibited.

\subsection{Variable Constraint Checking}

Any constraints on variables declared in the \code{transformed data}
block are checked after the statements are executed.  If any defined
variable violates its constraints, Stan will halt with a diagnostic
error message.


\section{Program Block: \code{parameters}}

The variables declared in the \code{parameters} program block
correspond directly to the variables being sampled by Stan's samplers
(\HMC and \NUTS).  From a user's perspective, the parameters in the
program block \emph{are} the parameters being sampled by Stan.

Variables declared as parameters cannot be directly assigned values.
So there is no block of statements in the \code{parameters} program
block.  Variable quantities derived from parameters may be declared in
the \code{transformed parameters} or \code{generated quantities} blocks,
or may be defined as local variables in any statement blocks following
their declaration.

There is a substantial amount of computation involved for parameter
variables in a Stan program at each leapfrog step within the
\HMC or \NUTS samplers, and a bit more computation along with writes
involved for saving the parameter values corresponding to a sample.

\subsection{Constraining Inverse Transform}

Stan's two samplers, standard Hamiltonian Monte Carlo (\HMC) and the
adaptive No-U-Turn sampler (\NUTS), are most easily (and often most
effectively) implemented over a multivariate probability density that
has support on all of $\reals^n$.  To do this, the parameters
defined in the \code{parameters} block must be transformed so they are
unconstrained.

In practice, the samplers keep an unconstrained parameter vector in
memory representing the current state of the sampler.  The model
defined by the compiled Stan program defines an (unnormalized) log
probability function over the unconstrained parameters.  In order to
do this, the log probability function must apply the inverse transform
to the unconstrained parameters to calculate the constrained
parameters defined in Stan's \code{parameters} program block.  The
log Jacobian of the inverse transform is then added to the accumulated
log probability function.  This then allows the Stan model to be
defined in terms of the constrained parameters.

In some cases, the number of parameters is reduced in the
unconstrained space.  For instance, a $K$-simplex only requires $K-1$
unconstrained parameters, and a $K$-correlation matrix only requires
$\binom{K}{2}$ unconstrained parameters.  This means that the
probability function defined by the compiled Stan program may have
fewer parameters than it would appear from looking at the declarations
in the \code{parameters} program block.

The probability function on the unconstrained parameters is defined in
such a way that the order of the parameters in the vector corresponds
to the order of the variables defined in the \code{parameters} program
block.  The details of the specific transformations are provided in
\refchapter{variable-transforms}.

\subsection{Gradient Calculation}

Hamiltonian Monte Carlo requires the gradient of the (unnormalized)
log probability function with respect to the unconstrained parameters
to be evaluated during every leapfrog step.  There may be one leapfrog
step per sample or hundreds, with more being required for models with
complex posterior distribution geometries.

Gradients are calculated behind the scenes using Stan's algorithmic
differentiation library.  The time to compute the gradient does not
depend directly on the number of parameters, only on the number of
subexpressions in the calculation of the log probability.  This
includes the expressions added from the transforms' Jacobians.

The amount of work done by the sampler does depend on the number of
unconstrained parameters, but this is usually dwarfed by the gradient
calculations.

\subsection{Writing Samples}

In the basic Stan compiled program, the values of variables are
written to a file for each sample.  The constrained versions of the
variables are written, again in the order they are defined in the
\code{parameters} block.  In order to do this, the transformed
parameter, model, and generated quantities statements must be
executed.


\section{Program Block: \code{transformed parameters}}

The \code{transformed parameters} program block consists of optional
variable declarations followed by statements.  After the statements
are executed, the constraints on the transformed parameters are
validated.  Any variable declared as a transformed parameter is part
of the output produced for samples.

Any variable that is defined wholly in terms of data or transformed
data should be declared and defined in the transformed data block.
Defining such quantities in the transformed parameters block is legal,
but much less efficient than defining them as transformed data.

\subsection{Constraints are for Error Checking}

Like the constraints on data, the constraints on transformed
parameters is meant to catch programming errors as well as convey
programmer intent.  They are not automatically transformed in such a
way as to be satisfied.  What will happen if a transformed parameter
does not match its constraint is that the current parameter values
will be rejected.  This can cause Stan's algorithms to hang or
to devolve to random walks.  It is not intended to be a way to enforce
ad hoc constraints in Stan programs.   See \refsection{reject-statements}
for further discussion of the behavior of reject statements.



\section{Program Block: \code{model}}

The \code{model} program block consists of optional variable
declarations followed by statements.  The variables in the model block
are local variables and are not written as part of the output.

Local variables may not be defined with constraints because there is
no well-defined way to have them be both flexible and easy to
validate.

The statements in the model block typically define the model.  This is
the block in which probability (sampling notation) statements are
allowed.  These are typically used when programming in the \BUGS idiom
to define the probability model.


\section{Program Block: \code{generated quantities}}

The \code{generated quantities} program block is rather different than
the other blocks.  Nothing in the generated quantities block affects
the sampled parameter values.  The block is executed only after a
sample has been generated.

Among the applications of posterior inference that can be coded in the
generated quantities block are
%
\begin{itemize}
\item forward sampling to generate simulated data for model testing,
\item generating predictions for new data,
\item calculating posterior event probabilities, including multiple comparisons,
  sign tests, etc.,
\item calculating posterior expectations,
\item transforming parameters for reporting,
\item applying full Bayesian decision theory,
\item calculating log likelihoods, deviances, etc.\ for model comparison.
\end{itemize}
%
Forward samples, event probabilities and statistics may all be
calculated directly using plug-in estimates.  Stan automatically
provides full Bayesian inference by producing samples from the
posterior distribution of any calculated event probabilities,
predictions, or statistics.  See \refchapter{bayesian} for more
information on Bayesian inference.

Within the generated quantities block, the values of all other variables
declared in earlier program blocks (other than local variables) are
available for use in the generated quantities block.

It is more efficient to define a variable in the generated quantities
block instead of the transformed parameters block.  Therefore, if a
quantity does not play a role in the model, it should be defined in
the generated quantities block.

After the generated quantities statements are executed, the constraints
on the declared generated quantity variables are validated.

All variables declared as generated quantities are printed as part of
the output.

\chapter{User-Defined Functions}\label{functions.chapter}%
%
\noindent
Stan allows users to define their own functions.  The basic syntax is
a simplified version of that used in C and \Cpp.  This chapter
specifies how functions are declared, defined, and used in Stan; see
\refchapter{functions-programming} for a more programming-oriented
perspective.

\section{Function-Definition Block}

User-defined functions appear in a special function-definition block
before all of the other program blocks.
%
\begin{stancode}
functions {
   // ... function declarations and definitions ...
}
data {
  // ...
\end{stancode}
%
Function definitions and declarations may appear in any order, subject
to the condition that a function must be declared before it is used.
Forward declarations are allowed in order to support recursive
functions.

\section{Function Names}

The rules for function naming and function-argument naming are the
same as for other variables; see \refsection{variables} for more
information on valid identifiers.  For example,
%
\begin{stancode}
real foo(real mu, real sigma);
\end{stancode}
%
declares a function named \code{foo} with two argument variables of
types \code{real} and \code{real}.  The arguments are named \code{mu}
and \code{sigma}, but that is not part of the declaration.  Two
user-defined functions may \emph{not} \, have the same name even if they have
different sequences of argument types.

\section{Calling Functions}

All function arguments are mandatory---there are no default values.

\subsection{Functions as Expressions}

Functions with non-void return types are called just like any other
built-in function in Stan---they are applied to appropriately typed
arguments to produce an expression, which has a value when executed.

\subsection{Functions as Statements}

Functions with void return types may be applied to arguments and used
as statements.  These act like sampling statements or print
statements.  Such uses are only appropriate for functions that act
through side effects, such as incrementing the log probability
accumulator, printing, or raising exceptions.

\subsection{Probability Functions in Sampling Statements}

Functions whose name ends in \code{\_lpdf} or \code{\_lpmf} (density
and mass functions) may be used as probability functions and may be
used in place of parameterized distributions on the right-hand-side of
sampling statements.  There is no restriction on where such functions
may be used.

\subsection{Restrictions on Placement}

Functions of certain types are restricted on scope of usage.
Functions whose names end in \code{\_lp} assume access to the log
probability accumulator and are only available in the transformed
parameter and model blocks.  Functions whose names end in \code{\_rng}
assume access to the random number generator and may only be used
within the generated quantities block, transformed data block, and
within user-defined functions ending in \code{\_rng}.  See
\refsection{function-bodies} for more information on these two special
types of function.

\section{Unsized Argument Types}

Stan's functions all have declared types for both arguments and
returned value.  As with built-in functions, user-defined functions are
only declared for base argument type and dimensionality.  This
requires a different syntax than for declaring other variables.  The
choice of language was made so that return types and argument types
could use the same declaration syntax.

The type \code{void} may not be used as an argument type, only a
return type for a function with side effects.


\subsection{Base Variable Type Declaration}

The base variable types are \code{integer}, \code{real},
\code{vector}, \code{row\_vector}, and \code{matrix}.  No lower-bound
or upper-bound constraints are allowed (e.g., \code{real<lower=0>} is
illegal).  Specialized types are also not allowed (e.g.,
\code{simplex} is illegal) .

\subsection{Dimensionality Declaration}

Arguments and return types may be arrays, and these are indicated with
optional brackets and commas as would be used for indexing.  For
example, \code{int} denotes a single integer argument or return,
whereas \code{real[~]} indicates a one-dimensional array of reals,
\code{real[~,~]} a two-dimensional array and \code{real[~,~,~]} a
three-dimensional array; whitespace is optional, as usual.

The dimensions for vectors and matrices are not included, so that
\code{matrix} is the type of a single matrix argument or return type.
Thus if a variable is declared as \code{matrix a}, then \code{a} has
two indexing dimensions, so that \code{a[1]} is a row vector and
\code{a[1,~1]} a real value.  Matrices implicitly have two indexing
dimensions.  The type declaration \code{matrix[,]~b} specifies that
\code{b} is a two-dimensional array of matrices, for a total of four
indexing dimensions, with \code{b[1,~1,~1,~1]} picking out a real value.

\subsection{Dimensionality Checks and Exceptions}

Function argument and return types are not themselves checked for
dimensionality.  A matrix of any size may be passed in as a matrix
argument.  Nevertheless, a user-defined function might call a function
(such as a multivariate normal density) that itself does
dimensionality checks.

Dimensions of function return values will be checked if they're
assigned to a previously declared variable.  They may also be checked
if they are used as the argument to a function.

Any errors raised by calls to functions inside user functions or
return type mismatches are simply passed on;  this typically results
in a warning message and rejection of a proposal during sampling or
optimization.

\section{Function Bodies}\label{function-bodies.section}

The body of a function is bounded by curly braces (\code{\{} and
\code{\}}).  The body may contain local variable declarations at the
top of the function body's block and these scope the same way as local
variables used in any other statement block.

The only restrictions on statements in function bodies are external,
and determine whether the log probability accumulator or random
number generators are available;  see the rest of this section for details.

\subsection{Random Number Generating Functions}

Functions that call random number generating functions in their bodies
must have a name that ends in \code{\_rng}; attempts to use
random-number generators in other functions leads to a compile-time
error.

Like other random number generating functions, user-defined functions
with names that end in \code{\_rng} may be used only in the generated
quantities block and transformed data block, or within the bodies of
user-defined functions ending in \code{\_rng}.  An attempt to use such
a function elsewhere results in a compile-time error.

\subsection{Log Probability Access in Functions}

Functions that include sampling statements or log probability
increment statements must have a name that ends in \code{\_lp}.
Attempts to use sampling statements or increment log probability
statements in other functions leads to a compile-time error.

Like the target log density increment statement and sampling
statements, user-defined functions with names that end in \code{\_lp}
may only be used in blocks where the log probability accumulator is
accessible, namely the transformed parameters and model blocks.  An
attempt to use such a function elsewhere results in a compile-time
error.

\subsection{Defining Probability Functions for Sampling Statements}

Functions whose names end in \code{\_lpdf} and \code{\_lpmf} (density
and mass functions) can be used as probability functions in sampling
statements.  As with the built-in functions, the first argument will
appear on the left of the sampling statement operator (\Verb|~|) in
the sampling statement and the other arguments follow.  For example,
suppose a function returning the log of the density of \code{y} given
parameter \code{theta} allows the use of the sampling statement is
defined as follows.
%
\begin{stancode}
real foo_lpdf(real y, vector theta) { ... }
\end{stancode}
%
Note that for function definitions, the comma is used rather than the
vertical bar.  Then the shorthand
%
\begin{stancode}
z ~ foo(phi);
\end{stancode}
%
will have exactly the same effect
%
\begin{stancode}
target += foo_lpdf(z | phi);
\end{stancode}
%
Unlike built-in probability functions, user-defined
probability functions like the example \code{foo} above will not
automatically drop constant terms.

The same syntax and shorthand works for log probability mass functions
with suffixes \code{\_lpmf}.

A function that is going to be accessed as distributions must return
the log of the density or mass function it defines.


\section{Parameters are Constant}

Within function definition bodies, the parameters may be used like any
other variable.  But the parameters are constant in the sense that
they can't be assigned to (i.e., can't appear on the left side of an
assignment (\code{=}) statement.  In other words, their value remains
constant throughout the function body.  Attempting to assign a value
to a function parameter value will raise a compile-time error.%
%
\footnote{Despite being declared constant and appearing to have a
  pass-by-value syntax in Stan, the implementation of the language
  passes function arguments by constant reference in C++.}

Local variables may be declared at the top of the function block and
scope as usual.

\section{Return Value}\label{function-returns.section}

Non-void functions must have a return statement that returns an
appropriately typed expression.   If the expression in a return
statement does not have the same type as the return type declared for
the function, a compile-time error is raised.

Void functions may use \code{return} only without an argument, but
return statements are not mandatory.

\subsection{Return Guarantee Required}

Unlike \Cpp, Stan enforces a syntactic guarantee for non-void
functions that ensures control will leave a non-void function through
an appropriately typed return statement or because an exception is
raised in the execution of the function.  To enforce this condition,
functions must have a return statement as the last statement in their
body.  This notion of last is defined recursively in terms of
statements that qualify as bodies for functions.  The base case is that
%
\begin{itemize}
\item a return statement qualifies,
\end{itemize}
%
and the recursive cases are that
%
\begin{itemize}
\item a sequence of statements qualifies if its last statement
  qualifies,
\item a for loop or while loop qualifies if its body qualifies, and
\item a conditional statement qualifies if it has a default else
  clause and all of its body statements qualify.
\end{itemize}
%
These rules disqualify
%
\begin{stancode}
real foo(real x) {
  if (x > 2) return 1.0;
  else if (x <= 2) return -1.0;
}
\end{stancode}
%
because there is no default \code{else} clause, and
disqualify
%
\begin{stancode}
real foo(real x) {
  real y;
  y = x;
  while (x < 10) {
    if (x > 0) return x;
    y = x / 2;
  }
}
\end{stancode}
%
because the return statement is not the last statement in the while
loop.  A bogus dummy return could be placed after the while loop in
this case.  The rules for returns allow
%
\begin{stancode}
real log_fancy(real x) {
  if (x < 1e-30)
    return x;
  else if (x < 1e-14)
    return x * x;
  else
    return log(x);
}
\end{stancode}
%
because there's a default else clause and each condition body has
return as its final statement.


\section{Void Functions as Statements}

\subsection{Void Functions}

A function can be declared without a return value by using \code{void}
in place of a return type.  Note that the type \code{void} may only be
used as a return type---arguments may not be declared to be of type
\code{void}.

\subsection{Usage as Statement}

A void function may be used as a statement after the function is
declared;  see \refsection{forward-declarations} for rules on declaration.

Because there is no return, such a usage is only for side effects,
such as incrementing the log probability function, printing, or
raising an error.

\subsection{Special Return Statements}

In a return statement within a void function's definition, the
\code{return} keyword is followed immediately by a semicolon
(\code{;}) rather than by the expression whose value is returned.


\section{Declarations}\label{forward-declarations.section}

In general, functions must be declared before they are used.  Stan
supports forward declarations, which look like function definitions
without bodies.  For example,
%
\begin{stancode}
real unit_normal_lpdf(real y);
\end{stancode}
%
declares a function named \code{unit\_normal\_log} that consumes a
single real-valued input and produces a real-valued output.  A
function definition with a body simultaneously declares and defines
the named function, as in
%
\begin{stancode}
real unit_normal_lpdf(real y) {
  return -0.5 * square(y);
}
\end{stancode}
%

A user-defined Stan function may be declared and then later defined,
or just defined without being declared.  No other combination of
declaration and definition is legal, so that, for instance, a function
may not be declared more than once, nor may it be defined more than
once.  If there is a declaration, there must be a definition.  These
rules together ensure that all the declared functions are eventually
defined.

\subsection{Recursive Functions}

Forward declarations allow the definition of self-recursive or
mutually recursive functions.  For instance, consider the following
code to compute Fibonacci numbers.
%
\begin{stancode}
int fib(int n);

int fib(int n) {
  if (n < 2) return n;
  else return fib(n-1) + fib(n-2);
}
\end{stancode}
%
Without the forward declaration in the first line, the body of the
definition would not compile.



\chapter{Execution of a Stan Program}

\noindent
This chapter provides a sketch of how a compiled Stan model is
executed using sampling.  Optimization shares the same data reading
and initialization steps, but then does optimization rather than sampling.

This sketch is elaborated in the following chapters of this part,
which cover variable declarations, expressions, statements, and blocks
in more detail.


\section{Reading and Transforming Data}

The reading and transforming data steps are the same for sampling,
optimization and diagnostics.

\subsection{Read Data}

The first step of execution is to read data into memory.   Data may be
read in through file (in CmdStan) or through memory (RStan and
PyStan);  see their respective manuals for details.%
%
\footnote{The \Cpp code underlying Stan is flexible enough to allow
  data to be read from memory or file.  Calls from \R, for instance,
  can be configured to read data from file or directly from \R's
  memory.}
%
All of the variables declared in the \code{data} block will be read.
If a variable cannot be read, the program will halt with a message
indicating which data variable is missing.

After each variable is read, if it has a declared constraint, the
constraint is validated.  For example, if a variable \code{N} is
declared as \code{int<lower=0>}, after \code{N} is read, it will be tested
to make sure it is greater than or equal to zero.  If a variable
violates its declared constraint, the program will halt with a warning
message indicating which variable contains an illegal value, the value
that was read, and the constraint that was declared.

\subsection{Define Transformed Data}

After data is read into the model, the transformed data variable
statements are executed in order to define the transformed data
variables.  As the statements execute, declared constraints on
variables are not enforced.

Transformed data variables are initialized with real values set to
\code{NaN} and integer values set to the smallest integer (large
absolute value negative number).

After the statements are executed, all declared constraints on
transformed data variables are validated.  If the validation fails,
execution halts and the variable's name, value and constraints are
displayed.

\section{Initialization}

Initialization is the same for sampling, optimization, and diagnosis

\subsection{User-Supplied Initial Values}

If there are user-supplied initial values for parameters, these are
read using the same input mechanism and same file format as data
reads.  Any constraints declared on the parameters are validated for
the initial values.  If a variable's value violates its declared
constraint, the program halts and a diagnostic message is printed.

After being read, initial values are transformed to unconstrained
values that will be used to initialize the sampler.

\subsubsection{Boundary Values are Problematic}

Because of the way Stan defines its transforms from the constrained to
the unconstrained space, initializing parameters on the boundaries of
their constraints is usually problematic.  For instance, with a
constraint
%
\begin{stancode}
parameters {
  real<lower=0,upper=1> theta;
  // ...
}
\end{stancode}
%
an initial value of 0 for \code{theta} leads to an unconstrained value
of $-\infty$, whereas a value of 1 leads to an unconstrained value of
$+\infty$.  While this will be inverse transformed back correctly
given the behavior of floating point arithmetic, the Jacobian will be
infinite and the log probability function will fail and raise an
exception.

\subsection{Random Initial Values}

If there are no user-supplied initial values, the default
initialization strategy is to initialize the unconstrained parameters
directly with values drawn uniformly from the interval $(-2,2)$.  The
bounds of this initialization can be changed but it is always
symmetric around 0. The value of 0 is special in that it represents
the median of the initialization.  An unconstrained value of 0
corresponds to different parameter values depending on the constraints
declared on the parameters.

An unconstrained real does not involve any transform, so an initial
value of 0 for the unconstrained parameters is also a value of 0 for
the constrained parameters.

For parameters that are bounded below at 0, the initial value of 0 on
the unconstrained scale corresponds to $\exp(0) = 1$ on the
constrained scale.  A value of -2 corresponds to $\exp(-2) = .13$ and
a value of 2 corresponds to $\exp(2) = 7.4$.

For parameters bounded above and below, the initial value of 0 on the
unconstrained scale corresponds to a value at the midpoint of the
constraint interval.  For probability parameters, bounded below by 0
and above by 1, the transform is the inverse logit, so that an initial
unconstrained value of 0 corresponds to a constrained value of 0.5, -2
corresponds to 0.12 and 2 to 0.88.  Bounds other than 0 and 1 are
just scaled and translated.

Simplexes with initial values of 0 on the unconstrained basis
correspond to symmetric values on the constrained values (i.e., each
value is $1/K$ in a $K$-simplex).

Cholesky factors for positive-definite matrices are initialized to 1
on the diagonal and 0 elsewhere;  this is because the diagonal is log
transformed and the below-diagonal values are unconstrained.

The initial values for other parameters can be determined from the
transform that is applied.  The transforms are all described in full
detail in \refchapter{variable-transforms}.

\subsection{Zero Initial Values}

The initial values may all be set to 0 on the unconstrained scale.
This can be helpful for diagnosis, and may also be a good starting
point for sampling.  Once a model is running, multiple chains with
more diffuse starting points can help diagnose problems with
convergence; see \refsection{convergence} for more information on
convergence monitoring.





\section{Sampling}

Sampling is based on simulating the Hamiltonian of a particle with a
starting position equal to the current parameter values and an initial
momentum (kinetic energy) generated randomly.  The potential energy at
work on the particle is taken to be the negative log (unnormalized) total
probability function defined by the model.  In the usual approach to
implementing \HMC, the Hamiltonian dynamics of the particle is
simulated using the leapfrog integrator, which discretizes the smooth
path of the particle into a number of small time steps called leapfrog
steps.

\subsection{Leapfrog Steps}

For each leapfrog step, the negative log probability function and its
gradient need to be evaluated at the position corresponding to the
current parameter values (a more detailed sketch is provided in the
next section).  These are used to update the momentum based on the
gradient and the position based on the momentum.

For simple models, only a few leapfrog steps with large step sizes are
needed.  For models with complex posterior geometries, many small
leapfrog steps may be needed to accurately model the path of the
parameters.

If the user specifies the number of leapfrog steps (i.e., chooses to
use standard \HMC), that number of leapfrog steps are simulated.  If
the user has not specified the number of leapfrog steps, the No-U-Turn
sampler (\NUTS) will determine the number of leapfrog steps adaptively
\citep{Hoffman-Gelman:2011, Hoffman-Gelman:2014}.

\subsection{Log Probability and Gradient Calculation}

During each leapfrog step, the log probability function and its
gradient must be calculated.  This is where most of the time in the
Stan algorithm is spent.  This log probability function, which is
used by the sampling algorithm, is defined over the unconstrained
parameters.

The first step of the calculation requires the inverse transform of
the unconstrained parameter values back to the constrained parameters
in terms of which the model is defined.  There is no error checking
required because the inverse transform is a total function on every point
in whose range satisfies the constraints.

Because the probability statements in the model are defined in terms
of constrained parameters, the log Jacobian of the inverse transform
must be added to the accumulated log probability.

Next, the transformed parameter statements are executed.  After they
complete, any constraints declared for the transformed parameters are
checked.  If the constraints are violated, the model will halt with a
diagnostic error message.

The final step in the log probability function calculation is to
execute the statements defined in the model block.

As the log probability function executes, it accumulates an in-memory
representation of the expression tree used to calculate the log
probability.  This includes all of the transformed parameter
operations and all of the Jacobian adjustments.  This tree is then
used to evaluate the gradients by propagating partial derivatives
backward along the expression graph.  The gradient calculations
account for the majority of the cycles consumed by a Stan program.

\subsection{Metropolis Accept/Reject}

A standard Metropolis accept/reject step is required to retain detailed
balance and ensure samples are marginally distributed according to the
probability function defined by the model.  This Metropolis adjustment
is based on comparing log probabilities, here defined by the
Hamiltonian, which is the sum of the potential (negative log
probability) and kinetic (squared momentum) energies.  In theory, the
Hamiltonian is invariant over the path of the particle and rejection
should never occur.  In practice, the probability of rejection is
determined by the accuracy of the leapfrog approximation to the true
trajectory of the parameters.

If step sizes are small, very few updates will be rejected, but many
steps will be required to move the same distance.  If step sizes are
large, more updates will be rejected, but fewer steps will be required
to move the same distance.  Thus a balance between effort and
rejection rate is required.  If the user has not specified a step
size, Stan will tune the step size during warmup sampling to achieve
a desired rejection rate (thus balancing rejection versus number of
steps).

If the proposal is accepted, the parameters are updated to their new
values.  Otherwise, the sample is the current set of parameter values.


\section{Optimization}

Optimization runs very much like sampling in that it starts by reading
the data and then initializing parameters.  Unlike sampling, it
produces a deterministic output which requires no further analysis
other than to verify that the optimizer itself converged to a
posterior mode.  The output for optimization is also similar to that
for sampling.


\section{Variational Inference}

Variational inference also runs similar to sampling. It begins by reading the
data and initializing the algorithm. The initial variational approximation is a
random draw from the standard normal distribution in the unconstrained
(real-coordinate) space. Again, similar to sampling, it outputs samples from the
approximate posterior once the algorithm has decided that it has converged.
Thus, the tools we use for analyzing the result of Stan's sampling routines can
also be used for variational inference.



\section{Model Diagnostics}

Model diagnostics are like sampling and optimization in that they
depend on a model's data being read and its parameters being
initialized.  The user's guides for the interfaces (RStan, PyStan,
CmdStan) provide more details on the diagnostics available; as of Stan
2.0, that's just gradients on the unconstrained scale and log
probabilities.

\section{Output}

For each final sample (not counting samples during warmup or samples
that are thinned), there is an output stage of writing the samples.

\subsection{Generated Quantities}

Before generating any output, the statements in the generated quantities
block are executed.  This can be used for any forward simulation based
on parameters of the model.  Or it may be used to transform parameters
to an appropriate form for output.

After the generated quantities statements execute, the constraints
declared on generated quantities variables are validated.   If these
constraints are violated, the program will terminate with a diagnostic message.

\subsection{Write}

The final step is to write the actual values.  The values of all
variables declared as parameters, transformed parameters, or generated
quantities are written.  Local variables are not written, nor is the
data or transformed data.  All values are written in their constrained
forms, that is the form that is used in the model definitions.

In the executable form of a Stan models, parameters, transformed
parameters, and generated quantities are written to a file in
comma-separated value (\acronym{csv}) notation with a header defining
the names of the parameters (including indices for multivariate
parameters).%
\footnote{In the \R version of Stan, the values may either be
written to a \acronym{csv} file or directly back to \R's memory.}

% PSEUDOCODE FOR STAN MODEL
% \begin{verbatim}
% read data into memory
% validate data constraints
% execute transformed data statements
% validate transformed data constraints
% read and inverse transform initial parameter values
%     (OR randomly initialize)
% for each sample desired:
%     if warming up and adapting, adapt step size
%     randomly initialize momentum
%     for each leapfrog step:
%         calculate log probability and gradient
%         increment momentum by half step-size times gradient
%         increment parameters by step-size times momentum
%         calculate log probability and gradient
%         increment momentum by half step-size times gradient
%     if not rejected by Metropolis condition:
%         update parameters to new values
%         execute transformed parameters statement
%         validate transformed parameters constraints
%         write parameters, transformed parameters, generated quantities
% \end{verbatim}
