\part*{Appendices}
\addcontentsline{toc}{part}{Appendices}


\chapter{Licensing}\label{licensing.appendix}

\noindent
Stan and its two dependent libraries, Boost and Eigen, are
distributed under liberal freedom-respecting%
%
\footnote{The link
  \url{http://www.gnu.org/philosophy/open-source-misses-the-point.html}
  leads to a discussion about terms ``open
  source'' and ``freedom respecting.''}
%
licenses approved by the Open Source Initiative.%
\footnote{See \url{http://opensource.org}.}  

In particular, the licenses for Stan and its dependent libraries have
no ``copyleft'' provisions requiring applications of Stan to be
open source if they are redistributed.

This chapter describes the licenses for the tools that are distributed
with Stan.  The next chapter explains some of the build tools that
are not distributed with Stan, but are required to build and run
Stan models.

\section{Stan's License}

Stan is distributed under the BSD 3-clause license (BSD New).
%
\begin{quote}
\url{http://www.opensource.org/licenses/BSD-3-Clause}
\end{quote}
%
The copyright holder of each contribution is the developer or his or
her assignee.%
%
\footnote{Universities or companies often own the copyright of
  computer programs developed by their employees.}


\section{Boost License}

Stan uses the Boost library for template metaprograms, traits
programs, the parser, and various numerical libraries for special
functions, probability functions, and random number generators.  Boost
is distributed under the Boost Software License version 1.0.
%
\begin{quote}
\url{http://www.opensource.org/licenses/BSL-1.0}
\end{quote}
%
The copyright for each Boost package is held by its developers or their
assginees.


\section{Eigen License} 

Stan uses the Eigen library for matrix arithmetic and linear algebra.
Eigen is distributed under the Mozilla Public License, version 2.
%
\begin{quote}
\url{http://opensource.org/licenses/mpl-2.0}
\end{quote}
%
The copyright of Eigen is owned jointly by its developers or their
assignees. 

\section{SUNDIALS License}

Stan uses the SUNDIALS package for solving stiff differential
equations.  SUNDIALS is distrubted under the new BSD (3-clause) license.
%
\begin{quote}
\url{https://opensource.org/licenses/BSD-3-Clause}
\end{quote}
%
The copyright of SUNDIALS is owned by Lawrence Livermore National
Security.

\section{Google Test License}

Stan uses Google Test for unit testing; it is not required to compile
or execute models.  Google Test is distributed under the new BSD (3-clause)
license.
%
\begin{quote}
\url{https://opensource.org/licenses/BSD-3-Clause}
\end{quote}
%
The copyright of Google Test is owned by Google, Inc.


\chapter{Stan for Users of BUGS}\label{stan-for-bugs.appendix}

From the outside, Stan and BUGS%
%
\footnote{Except where otherwise noted, we use ``BUGS'' to refer to
  WinBUGS, OpenBUGS, and JAGS, indiscriminately.}
%
are similar --- they use statistically-themed modeling languages
(which are similar but with some differences; see below), they can be
called from R, running some specified number of chains to some
specified length, producing posterior simulations that can be assessed
using standard convergence diagnostics.  This is not a coincidence:
in designing Stan, we wanted to keep many of the useful features of
Bugs.

To start, take a look at the files of translated \BUGS models at
\url{http://mc-stan.org/}.  These are 40 or so models from the \BUGS
example volumes, all translated and tested (to provide the same
answers as \BUGS) in Stan.  For any particular model you want to fit,
you can look for similar structures in these examples.

\section{Some Differences in How BUGS and Stan Work}

\begin{itemize}
\item \BUGS is interpreted; Stan is compiled in two steps, first a
  model is is translated to templated C++ and then to a
  platform-specific executable.  Stan, unlike \BUGS, allows the user
  to directly program in C++, but we do not describe how to do this in
  this Stan manual (see the getting started with \Cpp section of
  \url{http://mc-stan.org} for more information on using Stan directly
  from \Cpp). 
\item \BUGS performs \MCMC updating one scalar parameter at a time
  (with some exceptions such as \JAGS's implementation of regression
  and generalized linear models and some conjugate multivariate
  parameters), using conditional distributions (Gibbs sampling) where
  possible and otherwise using adaptive rejection sampling, slice
  sampling, and Metropolis jumping.  \BUGS figures out the dependence
  structure of the joint distribution as specified in its modeling
  language and uses this information to compute only what it needs at
  each step.  Stan moves in the entire space of all the parameters
  using Hamiltonian Monte Carlo (more precisely, the no-U-turn
  sampler), thus avoiding some difficulties that occur with
  one-dimension-at-a-time sampling in high dimensions but at the cost
  of requiring the computation of the entire log density at each step.
\item \BUGS tunes its adaptive jumping (if necessary) during its
  warmup phase (traditionally referred to as "burn-in").  Stan uses
  its warmup phase to tune the no-U-turn sampler (\NUTS).
\item The \BUGS modeling language is not directly executable.  Rather,
  \BUGS parses its model to determine the posterior density and then
  decides on a sampling scheme.  In contrast, the statements in a Stan
  model are directly executable: they translate exactly into C++ code
  that is used to compute the log posterior density (which in turn is
  used to compute the gradient).
\item In \BUGS, the order in which statements are written does not
  matter.  They are executed according to the directed graphical model
  so that variables are always defined when needed.  A side effect of
  the direct execution of Stan's modeling language is that statements
  execute in the order in which they are written.  For instance, the
  following Stan program, which sets \code{mu} before using it to
  sample \code{y}.
%
\begin{stancode}
mu = a + b * x;
y ~ normal(mu,sigma);
\end{stancode}
%
It translates to the following \Cpp code.
%
\begin{stancode}
mu = a + b * x; 
lp += normal_log(mu,sigma);
\end{stancode}
%
Contrast this with the Stan program
%
\begin{stancode}
y ~ normal(mu,sigma)
mu = a + b * x
\end{stancode}
%
This program is well formed, but is almost certainly  
a coding error, because it attempts to use \code{mu} before 
it is set. It translates to the following \Cpp code.
%
\begin{stancode}
lp += normal_log(mu,sigma);
mu = a + b * x;
\end{stancode}
%
The direct translation to the imperative language of \Cpp code
highlights the potential error of using \code{mu} in the first
statement.
\\[8pt]
To trap these kinds of errors, variables are initialized to the
special not-a-number (\code{NaN}) value.  If \code{NaN} is passed to a
log probability function, it will raise a domain exception, which will
in turn be reported by the sampler.  The sampler will reject the
sample out of hand as if it had zero probability.
%
\item Stan uses its own \Cpp algorithmic differentiation packages to
  compute the gradient of the log density (up to a proportion).
  Gradients are required during the Hamiltonian dynamics simulations
  within the leapfrog algorithm of the Hamiltonian Monte Carlo and
  \NUTS samplers.  \BUGS computes the log density but not its
  gradient.
\item Both \BUGS and Stan are semi-automatic in that they run by
  themselves with no outside tuning required. Nevertheless, the user
  needs to pick the number of chains and number of iterations per
  chain.  We usually pick 4 chains and start with 10 iterations per
  chain (to make sure there are no major bugs and to approximately
  check the timing), then go to 100, 1000, or more iterations as
  necessary.  Compared to Gibbs or Metropolis, Hamiltonian Monte Carlo
  can take longer per iteration (as it typically takes many "leapfrog
  steps" within each iteration), but the iterations typically have lower
  autocorrelation.  So Stan might work fine with 1000 iterations in an
  example where \BUGS would require 100,000 for good mixing.  We 
  recommend monitoring potential scale reduction statistics ($\hat{R}$)
  and the effective sample size to judge when to stop (stopping when
  $\hat{R}$ values do not counter-indicate convergence and when enough
  effective samples have been collected).
\item WinBUGS is closed source.  OpenBUGS and JAGS are both licensed
  under the Gnu Public License (GPL), otherwise known as copyleft due
  to the restrictions it places on derivative works.  Stan is licensed
  under the much more liberal new BSD license.
\item Like WinBUGS, OpenBUGS and JAGS, Stan can be run directly from
  the command line or through R (Python and MATLAB interfaces are in
  the works)
\item Like OpenBUGS and JAGS, Stan can be run on Linux, Mac, and
  Windows platforms.
\end{itemize}

\section{Some Differences in the Modeling Languages}

\begin{itemize}
\item The \BUGS modeling language follows an R-like syntax in which
  line breaks are meaningful.  Stan follows the rules of C, in which
  line breaks are equivalent to spaces, and each statement ends in a
  semicolon.  For example:
%
\begin{stancode}
y ~ normal(mu, sigma);
\end{stancode}
%
and
%
\begin{stancode}
for (i in 1:n) y[i] ~ normal(mu, sigma);
\end{stancode}
%
Or, equivalently (recall that a line break is just another form of whitespace),
%
\begin{stancode}
for (i in 1:n)
  y[i] ~ normal(mu, sigma);
\end{stancode}
%
and also equivalently, 
%
\begin{stancode}
for (i in 1:n) {
  y[i] ~ normal(mu, sigma);
}
\end{stancode}
%
There's a semicolon after the model statement but not after the
brackets indicating the body of the for loop.
%
\item Another C thing: In Stan, variables can have names constructed
  using letters, numbers, and the underscore (\code{\_}) symbol, but
  nothing else (and a variable name cannot begin with a number).
  \BUGS variables can also include the dot, or period (\code{.}) symbol.
%
\item In Stan, the second argument to the "normal" function is the
  standard deviation (i.e., the scale), not the variance (as in {\it
    Bayesian Data Analysis}) and not the inverse-variance (i.e.,
  precision) (as in \BUGS).  Thus a normal with mean 1 and standard
  deviation 2 is \code{normal(1,2)}, not \code{normal(1,4)} or
  \code{normal(1,0.25)}.
%
\item Similarly, the second argument to the "multivariate normal" 
  function is the covariance matrix and not the inverse covariance matrix
  (i.e., the precision matrix) (as in \BUGS). The same is true for
  the "multivariate student" distribution.
%  
\item
The distributions have slightly different names:
%
\begin{quote}
\begin{tabular}{l|l}
{\it BUGS} & {\it Stan} \\ \hline \hline
\code{dnorm} & \code{normal} \\
\code{dbinom} & \code{binomial} \\
\code{dpois} & \code{poisson} \\
$\vdots$ & $\vdots$
\end{tabular}
\end{quote}
%
\item Stan, unlike \BUGS, allows intermediate quantities, in the form
  of local variables, to be reassigned.  For example, the following is
  legal and meaningful (if possibly inefficient) Stan code.
%
\begin{stancode}
{
  total = 0;
  for (i in 1:n){
    theta[i] ~ normal(total, sigma);
    total = total + theta[i];
  }
}
\end{stancode}
%
In \BUGS, the above model would not be legal because the variable
\code{total} is defined more than once.  But in Stan, the loop is
executed in order, so \code{total} is overwritten in each step.  
%
\item Stan uses explicit declarations.  Variables are declared with
  base type integer or real, and vectors, matrices, and arrays have
  specified dimensions.  When variables are bounded, we give that
  information also.  For data and transformed parameters, the bounds
  are used for error checking.  For parameters, the constraints
  are critical to sampling as they determine the geometry over which
  the Hamiltonian is simulated.  
  \\[6pt]
  Variables can be declared as data, transformed data, parameters, transformed
  parameters, or generated quantities.  They can also be declared as
  local variables within blocks.  For more information, see
  the part of this manual devoted to the Stan programming language and
  examine at the example models.
%
\item Stan allows all sorts of tricks with vector and matrix
  operations which can make Stan models more compact.  For example,
  arguments to probability functions may be vectorized,%
%
\footnote{Most distributions have been vectorized, but currently the
truncated versions may not exist and may not be vectorized.}
%
allowing
%
\begin{stancode}
for (i in 1:n) 
  y[i] ~ normal(mu[i], sigma[i]);
\end{stancode}
%
to be expressed more compactly as 
%
\begin{stancode}
y ~ normal(mu,sigma);
\end{stancode}
%
The vectorized form is also more efficient because Stan can unfold the
computation of the chain rule during algorithmic differentiation.
%
\item Stan also allows for arrays of vectors and matrices.
  For example, in a hierarchical model might have a vector of \code{K}
  parameters for each of \code{J} groups; this can be declared using
\begin{stancode}
vector[K] theta[J];
\end{stancode}
%
Then \code{theta[j]} is an expression denoting a \code{K}-vector and
may be used in the code just like any other vector variable.
\\[6pt]
An alternative encoding would be with a two-dimensional array, as in
\begin{stancode}
real theta[J,K];
\end{stancode}
%
The vector version can have some advantages, both in convenience and
in computational speed for some operations.
\\[6pt]
A third encoding would use a matrix:
%
\begin{stancode}
matrix[J,K] theta;
\end{stancode}
%
but in this case, \code{theta[j]} is a row vector, not a vector, and
accessing it as a vector is less efficient than with an array of
vectors.  The transposition operator, as in \code{theta[j]'}, may be
used to convert the row vector \code{theta[j]} to a (column) vector.
Column vector and row vector types are not interchangeable everywhere
in Stan; see the function signature declarations in the programming
language section of this manual.
%
\item Stan supports general conditional statements using a standard
  if-else syntax.  For example, a zero-inflated (or -deflated) Poisson
  mixture model is defined using the if-else syntax as described in
  \refsection{zero-inflated}. 
%
\item Stan supports general while loops using a standard syntax.  
While loops give Stan full Turing equivalent computational power.
They are useful for defining iterative functions with complex
termination conditions.  As an illustration of their syntax,
the for-loop
%
\begin{stancode}
model {
    ....
    for (n in 1:N) {
        ... do something with n ....
    }
}
\end{stancode}
%
may be recoded using the following while loop.
%
\begin{stancode}
model {
    int n;
    ...
    n = 1;
    while (n <= N) {
        ... do something with n ...
        n = n + 1;
    }
}
\end{stancode}
%


\end{itemize}


\section{Some Differences in the Statistical Models that are Allowed}

\begin{itemize}
\item Stan does not yet support estimation of discrete parameters
  (discrete data is supported).  We may eventually implement a
  combination of Gibbs and slice sampling for discrete parameters, but
  we haven't done so yet.
\item Stan has some distributions on covariance matrices that do not
  exist in \BUGS, including a uniform distribution over correlation
  matrices which may be rescaled, and the priors based on C-vines
  defined in \citep{LewandowskiKurowickaJoe:2009}.  In particular, the
  Lewandowski et al.\ prior allows the correlation matrix to be shrunk
  toward the unit matrix while the scales are given independent priors.
\item In \BUGS you need to define all variables.  In Stan, if you
  declare but don't define a parameter it implicitly has a flat prior
  (on the scale in which the parameter is defined).  For example, if
  you have a parameter \code{p} declared as 
\begin{stancode}
real<lower=0,upper=1> p;
\end{stancode}
%
and then have no sampling statement for \code{p} in the \code{model}
block, then you are implicitly assigning a uniform $[0,1]$ prior on
\code{p}.
On the other hand, if you have a parameter \code{theta} declared with
%
\begin{stancode}
real theta;
\end{stancode}
%
and have no sampling statement for \code{theta} in the
\code{model} block, 
 then you are implicitly assigning an improper uniform prior
on $(-\infty,\infty)$ to \code{theta}.  
%
% Then if
% you define a transformed parameter \code{p} using
% \begin{stancode}
% p = invlogit(theta);
% \end{stancode}
% %
% then you get a $\distro{Beta}(0,0)$ on \code{p}.
% then you are implicitly assigning an improper uniform
% (-infinity, infinity) prior on theta, which corresponds to a Beta
% (0,0) prior on p.  You could also assign this latter prior directly by
% defining p as the parameter and then writing the following within the
% model: p ~ beta (0, 0);
\item \BUGS models are always proper (being constructed as a product
  of proper marginal and conditional densities).  Stan models can be
  improper.  Here is the simplest improper Stan model: 
\begin{stancode}
parameters {
  real theta;
} 
model { }
\end{stancode}
% \item You can also define some improper models in \BUGS directly, for
%   example, \Verb|p ~ beta (0, 0);| Remember how Stan works:
%   lines in the model are executables that correspond directly to
%   factors in the posterior density.  So you can define beta(0,0), it's
%   simply a mathematical function.  Stan doesn't "care" if it has a
%   finite integral.
\item Although parameters in Stan models may have improper priors, we
  do not want improper \emph{posterior} distributions, as we are trying to
  use these distributions for Bayesian inference.  There is no general
  way to check if a posterior distribution is improper.  But if all
  the priors are proper, the posterior will be proper also.
\item
  As noted earlier, each statement in a Stan model is directly translated into the \Cpp code for computing the log posterior.  Thus, for example, the following pair of statements is legal in a Stan model:
\begin{stancode}
y ~ normal(0,1);
y ~ normal(2,3);
\end{stancode}
%
The second line here does \emph{not} simply overwrite the first;
rather, \emph{both} statements contribute to the density function that
is evaluated.  The above two lines have the effect of including the
product, $\distro{Norm}(y|0,1) \times \distro{Norm}(y|2,3)$, into the
density function.
\\[6pt] 
For a perhaps more confusing example, consider the following two lines in a Stan model:
\begin{stancode}
x ~ normal(0.8*y, sigma);
y ~ normal(0.8*x, sigma);
\end{stancode}
%
At first, this might look like a joint normal distribution with a
correlation of 0.8.  But it is not.  The above are \emph{not}
interpreted as conditional entities; rather, they are factors in the
joint density.  Multiplying them gives, $\distro{Norm}(x|0.8y,\sigma)
\times \distro{Norm}(y|0.8x,\sigma)$, which is what it is (you can
work out the algebra) but it is not the joint distribution where the
conditionals have regressions with slope 0.8.
%
\item With censoring and truncation, Stan uses the censored-data or
  truncated-data likelihood---this is not always done in \BUGS.  All
  of the approaches to censoring and truncation discussed in
  \citep{GelmanEtAl:2013} and \citep{GelmanHill:2007} may
  be implemented in Stan directly as written.
%
\item Stan, like \BUGS, can benefit from human intervention in the
  form of reparameterization.  More on this topic to come.
  % For example, with the 8 schools: . . .
\end{itemize}

\section{Some Differences when Running from R}

\begin{itemize}

\item Stan can be set up from within R using two lines of code.
  Follow the instructions for running Stan from R on
  \url{http://mc-stan.org/}.  You don't need to separately download
  Stan and RStan.  Installing RStan will automatically set up Stan.
  When RStan moves to CRAN, it will get even easier.
\item In practice we typically run the same Stan model repeatedly.  If
  you pass RStan the result of a previously fitted model the model will 
  not need be recompiled. An example is given on the running
  Stan from R pages available from \code{http://mc-stan.org/}.
\item When you run Stan, it saves various conditions including
  starting values, some control variables for the tuning and running
  of the no-U-turn sampler, and the initial random seed. You can
  specify these values in the Stan call and thus achieve exact
  replication if desired.  (This can be useful for debugging.)
\item When running \BUGS from R, you need to send exactly the data
  that the model needs.  When running RStan, you can include extra
  data, which can be helpful when playing around with models.  For
  example, if you remove a variable \code{x} from the model, you can keep
  it in the data sent from R, thus allowing you to quickly alter the
  Stan model without having to also change the calling information in
  your R script.
\item As in R2WinBUGS and R2jags, after running the Stan model, you
  can quickly summarize using \code{plot()} and \code{print()}.  You
  can access the simulations themselves using various extractor
  functions, as described in the RStan documentation.  
\item Various information about the sampler, such as number of
  leapfrog steps, log probability, and step size, is available through
  extractor functions.   These can be useful for understanding what is
  going wrong when the algorithm is slow to converge.
\end{itemize}

\section{The Stan Community}

\begin{itemize}
\item Stan, like WinBUGS, OpenBUGS, and JAGS, has an active community,
  which you can access via the user's mailing list and the developer's
  mailing list; see \code{http://mc-stan.org/} for information on
  subscribing and posting and to look at archives.
\end{itemize}

\chapter{Modeling Language Syntax}

\noindent
This chapter defines the basic syntax of the Stan modeling language
using a Backus-Naur form (\BNF) grammar plus extra-grammatical
constraints on function typing and operator precedence and
associativity.

\section{BNF Grammars}

\subsection{Syntactic Conventions}

In the following \BNF grammars, literal strings are indicated in
single quotes (\Verb|'|).  Grammar non-terminals are unquoted strings.
A prefix question mark (\code{?A}) indicates optionality of \code{A}.
A postfixed Kleene star (\code{A*}) indicates zero or more occurrences
of \code{A}.  The notation \code{A \% B}, following the Boost Spirit
parser library's notation, is shorthand for \code{?(A (B A)*)}, i.e.,
any number of \code{A} (including zero), separated by \code{B}.  A
postfixed, curly-braced number indicates a fixed number of repetions;
e.g., \code{A\{6\}} is equivalent to a sequence of six copies of \code{A}.

\subsection{Programs}

{\small
\begin{Verbatim}
program ::= ?functions ?data ?tdata ?params ?tparams model ?generated

functions ::= 'functions' function_decls
data ::= 'data' var_decls
tdata ::= 'transformed data' var_decls_statements
params ::= 'parameters' var_decls
tparams ::= 'transformed parameters' var_decls_statements
model ::= 'model' statement
generated ::= 'generated quantities' var_decls_statements

function_decls ::= '{' function_decl* '}'
var_decls ::= '{' var_decl* '}'
var_decls_statements ::= '{' var_decl* statement* '}'
\end{Verbatim}
}

\subsection{Function Declarations}

{
\small
\begin{Verbatim}[fontsize=\small]
function_decl ::= unsized_return_type identifier '(' unsized_types ')'
                 statement

unsized_return_type ::= 'void' | unsized_type
unsized_type ::= (basic_type ?unsized_dims)
unsized_types ::= unsized_type % ','
basic_type ::= 'int' | 'real' | 'vector' | 'row_vector' | 'matrix'
unsized_dims ::= '['  ','*  ']'
\end{Verbatim}
}

\subsection{Variable Declarations}

{
\small
\begin{Verbatim}[fontsize=\small]
var_decl ::= var_type variable ?dims ?('=' expression) ';'

var_type ::= 'int' range_constraint
           | 'real' range_constraint
           | 'vector' range_constraint '[' expression ']'
           | 'ordered' '[' expression ']'
           | 'positive_ordered' '[' expression ']'
           | 'simplex' '[' expression ']'
           | 'unit_vector' '[' expression ']'
           | 'row_vector' range_constraint '[' expression ']'
           | 'matrix' range_constraint '[' expression ',' expression ']'
           | 'cholesky_factor_corr' '[' expression ']'
           | 'cholesky_factor_cov' '[' expression ?(',' expression) ']'
           | 'corr_matrix' '[' expression ']'
           | 'cov_matrix' '[' expression ']'

range_constraint ::= ?('<' range '>')

range ::= 'lower' '=' expression ',' 'upper' = expression
        | 'lower' '=' expression
        | 'upper' '=' expression

dims ::= '['  expressions ']'

variable ::= identifier

identifier ::= [a-zA-Z] [a-zA-Z0-9_]*
\end{Verbatim}
}

\subsection{Expressions}

{
\small
\begin{Verbatim}[fontsize=\small]
expressions ::= expression % ','
expression ::= numeric_literal
             | variable
             | '{' expressions '}'
             | expression `?` expression `:` expression
             | expression infixOp expression
             | prefixOp expression
             | expression postfixOp
             | expression '[' indexes ']'
             | function_literal '(' ?expressions ')'
             | function_literal '(' expression ?('|' expression % ',') ')'
             | integrate_ode '(' function_literal (',' expression){6} ')'
             | integrate_ode_rk45
               '(' function_literal (',' expression){6|9} ')'
             | integrate_ode_bdf
               '(' function_literal (',' expression){6|9} ')'
             | '(' expression ')'

index ::= ?(expression | expression ':' | ':' expression
            | expression ':' expression)

indexes ::= index % ','

numeric_literal ::= integer_literal | real_literal

integer_literal ::= 0 | [1-9] [0-9]*

real_literal ::= integer_literal ?('.' [0-9]*) ?exp_literal

exp_literal ::= ('e' | 'E') integer_literal

function_literal ::= identifier
\end{Verbatim}
}

\subsection{Statements}

{
\small
\begin{Verbatim}[fontsize=\small]
statement ::= atomic_statement | nested_statement

atomic_statement ::= atomic_statement_body ';'
atomic_statement_body
::=  lhs ('=' | '<-') expression
   | expression '~' identifier '(' expressions ')' ?truncation
   | function_literal '(' expressions ')'
   | 'increment_log_prob' '(' expression ')'
   | 'target' '+=' expression
   | 'break'
   | 'continue'
   | 'print' '(' (expression | string_literal)* ')'
   | 'reject' '(' (expression | string_literal)* ')'
   | 'return' expression
   | ''

string_literal ::= '"' char* '"'

truncation ::= 'T' '[' ?expression ',' ?expression ']'

lhs ::= identifier ?('[' indexes ']')

nested_statement
::=
  | 'if' '(' expression ')' statement
    ('else' 'if' '(' expression ')' statement)*
    ?('else' statement)
  | 'while' '(' expression ')' statement
  | 'for' '(' identifier 'in' expression ':' expression ')' statement
  | '{' var_decl* statement+ '}'
\end{Verbatim}
%
}

\section{Extra-Grammatical Constraints}

\subsection{Type Constraints}

A well-formed Stan program must satisfy the type constraints imposed
by functions and distributions.  For example, the binomial
distribution requires an integer total count parameter and integer
variate and when truncated would require integer truncation points.
If these constraints are violated, the program will be rejected during
parsing with an error message indicating the location of the problem.
For information on argument types, see \refpart{built-in-functions}.

\subsection{Operator Precedence and Associativity}

In the Stan grammar provided in this chapter, the expression \code{1
  + 2 * 3} has two parses.  As described in
\refsection{arithmetic-expressions}, Stan disambiguates between the
meaning $1 + (2 \times 3)$ and the meaning $(1 + 2) \times 3$ based on
operator precedences and associativities.

\subsection{Typing of Compound Declaration and Definition}

In a compound variable declaration and definition, the type of the
right-hand side expression must be assignable to the variable being
declared.  The assignability constraint restricts compound
declarations and definitions to local variables and variables declared
in the transformed data, transformed parameters, and generated
quantities blocks.

\subsection{Typing of Array Expressions}

The types of expressions used for elements in array expressions
(\Verb|'{' expressions '}'|) must all be of the same type or a mixture
of \code{int} and \code{real} types (in which case the result is
promoted to be of type \code{real}).

\subsection{Forms of Numbers}

Integer literals longer than one digit may not start with 0 and real
literals cannot consist of only a period or only an exponent.

\subsection{Conditional Arguments}

Both the conditional if-then-else statement and while-loop statement
require the expression denoting the condition to be a primitive type,
integer or real.

\subsection{Print Arguments}

The arguments to a print statement cannot be void.

\subsection{Only Break and Continue in Loops}

The \code{break} and \code{continue} statements may only be used
within the body of a for-loop or while-loop.

\subsection{PRNG Function Locations}

Functions ending in \code{\_rng} may only be called in the transformed
data and generated quantities block, and within the bodies of
user-defined functions with names ending in \code{\_rng}.

\subsection{Probability Function Naming}

A probability function literal must have one of the following
suffixes: \code{\_lpdf}, \code{\_lpmf}, \code{\_lcdf}, or \code{\_lccdf}.

\subsection{ODE Solver Argument Types and Origins}

The \code{integrate\_ode}, \code{integrate\_ode\_rk45}, and
\code{integrate\_ode\_bdf} functions may be used without control
parameters;  in this case
%
\begin{itemize}
\item its first argument to refer to a function with signature
\begin{quote}
 \code{(real,~real[],~real[],~real[],~int[])~:~real[]},
\end{quote}
\item the remaining six arguments must assignable to types
\begin{quote}
  \code{real[]}, \code{real}, \code{real[]}, \code{real[]},
\code{real[]}, and \code{int[]}
\end{quote}
 respectively, and
\item the third, fourth, and sixth arguments must be expressions not
  containing any variables not originating in the data or transformed
  data blocks.
\end{itemize}
%
The \code{integrate\_ode\_rk45} and \code{integrate\_ode\_bdf}
functions may accept three additional arguments, which like the third,
fourth, and sixth arguments, must be expressions free of parameter
references.  The final three arguments must be assignable to types
\begin{quote}
\code{real}, \code{real}, \code{int}.
\end{quote}

\subsection{Indexes}

Standalone expressions used as indexes must denote either an integer
(\code{int}) or an integer array (\code{int[]}).  Expressions
participating in range indexes (e.g., \code{a} and \code{b} in
\code{a~:~b}) must denote integers (\code{int}).

A second condition is that there not be more indexes provided than
dimensions of the underlying expression (in general) or variable (on
the left side of assignments) being indexed.  A vector or row vector
adds 1 to the array dimension and a matrix adds 2.  That is, the type
\code{matrix[\,,\,,\,]}, a three-dimensional array of matrices, has five
index positions: three for the array, one for the row of the matrix
and one for the column.

\chapter{Warning and Error Messages}\label{error-messages.appendix}

\noindent
This appendix details the specific error messages returned by the
underlying Stan engine.  The individual Stan interfaces (RStan,
PyStan, CmdStan) also return error or warning messages in some
circumstances.

\section{Warnings vs.\ Errors}

The messages returned by Stan come in two flavors, warnings and
errors.  Error messages arise when a fatal problem occurs under the
hood from which there is no way to recover.  Warning messages arise
in circumstances from which the underlying program can continue to
operaate.  

An example warning message is an informational message about
ill-formed input to an underlying function, which results in a
Metropolis rejection during sampling or a reduction in step size for
optimization, without causing a fatal error.  An example error message
is when either sampling or optimization cannot find a region of
non-zero probability or when a program being parsed is ill formed.
When an error arises, whatever program is running cannot continue and
the entire execution must halt.

\section{Parsing and Compilation}

Both warning messages and error messages may arise during parsing.  If
a Stan program parses successfully, it should compile in \Cpp as
well.  If it does not compile, there is an underlying bug in Stan's
parser and \Cpp code generator.

\begin{itemize}
\item {\it Jacobian may be necessary.}  This message arises when the
  parser cannot verify that the left-hand side of a sampling statement
  is a linear function of a parameter.  If it is not a linear function
  of the parameters, a Jacobian adjustment must be applied.  See
  \refchapter{change-of-variables} for more information on how to
  adjust for the Jacobian of a non-linear transform
\end{itemize}


\section{Initialization}

\begin{itemize}
\item {\it vanishing density.} This message arrises when there is a
  problem with initialization not providing a finite log probability.
%
\end{itemize}

\section{Function Evaluation}

\begin{itemize}
\item {\it informational message.}  This message shows up during
  sampling when there is a rejected sample due to an underlying issue
  with input to an underlying function (including probably functions
  and sampling statements).  This is a {\it warning}\, message, not an
  error message.  If it only appears at the beginning of warmup in
  MCMC or during early iterations of optimization, it indicates that
  adaptation has not yet found appropriate scales for the parameters
  and an appropriate overall stepsize.  This causes problem like
  overflow or underflow and thus causes illegal inputs to be passed to
  functions.  Even if this message persists during sampling, the
  Metropolis acceptance step will account for the problem and the
  parameter values being evaluated will be rejected.  This can lead to
  inefficiency in the best case and lack of ability to make progress
  in the worst case.  In cases where the message persists, it is worth
  investigating the arithmetic stability of the Stan program.  There
  are several tips in this manual and in the user group about how to
  rewrite problematic programs.
\end{itemize}

\chapter{Deprecated Features}\label{deprecated-features.appendix}

\noindent
This appendix lists currently deprecated functionality.  These
deprecated features are likely to be removed in the next major
release.  \refsection{process-deprecation} describes the deprecation
process.  The rest of this appendix lists deprecated functionality and
how to upgrade it.

\section{Assignment with \code{<-}}

\begin{description}
\item[Deprecated] The deprecated syntax uses the operator \code{<-}
  for assignment, e.g., 
\begin{stancode}
a <- b;
\end{stancode}
\item[Replacement] The new syntax uses the operator \code{=} for
  assignment, e.g.,
\begin{stancode}
a = b;
\end{stancode}
\end{description}

\section{\code{increment\_log\_prob} Statement}

\begin{description}
\item[Deprecated] The deprecated syntax for incrementing the log
  density accumulator by \code{u} is
\begin{stancode}
increment_log_prob(u);
\end{stancode}
If \code{u} is an expression of real type, the underlying log density
accumulator is incremented by \code{u};  if \code{u} is a container,
the underlying log density is incremented with each element.
\item[Replacement] Replace the above statement with
\begin{stancode}
target += u;
\end{stancode}
\end{description}

\section{\code{lp\_\_} Variable}

\begin{description}
\item[Depcreated]
The variable \code{lp\_\_} is available wherever log density increment
statements are allowed (\code{target~+=} and \Verb|~| shorthand
statements).
\item[Replacement]
General manipulation of \code{lp\_\_} is not allowed, but
\begin{stancode}
lp__ <- lp__ + e;
\end{stancode}
%
can be replaced with
%
\begin{stancode}
target += e;
\end{stancode}
%
The value of \code{lp\_\_} is available through the no-argument
function \code{target()}.
\end{description}

\section{\code{get\_lp()} Function}

\begin{description}
\item[Deprecated]
The no-argument function \code{get\_lp()} is deprecated.
\item[Replacement]
Use the no-argument function \code{target()} instead.
\end{description}

\section{\code{\_log} Density and Mass Functions}

\begin{description}
\item[Deprecated] The probability function for the distribution
  \code{foo} will be applied to an outcome variable \code{y} and
  sequence of zero or more parameters \code{...} to produce the
  expression \code{foo\_log(y, ...)}.
\item[Replacement] If \code{y} can be a real value (including vectors
or matrices), replace 
%
\begin{stancode}
foo_log(y, ...)
\end{stancode}
%
with the log probability density function notation
%
\begin{stancode}
foo_lpdf(y | ...).
\end{stancode}
%
If \code{y} must be an integer (including arrays),
instead replace
%
\begin{stancode}
foo_log(y, ...
\end{stancode}
%
with the log probability mass function
%
\begin{stancode}
foo_lpmf(y | ...).
\end{stancode}
\end{description}

\section{\code{cdf\_log} and \code{ccdf\_log} Cumulative Distribution
  Functions} 

\begin{description}
\item[Deprecated] 
The log cumulative distribution and complementary cumulative
distribution functions for a distribution \code{foo} are currently
written as \code{foo\_cdf\_log} and \code{foo\_ccdf\_log}.  
\item[Replacement]
Replace \code{foo\_cdf\_log(y, ...)} with \code{foo\_lcdf(y | ...)}.
\\[4pt]
Replace \code{foo\_ccdf\_log(y, ...)} with \code{foo\_lccdf(y | ...)}.
\end{description}

\section{\code{multiply\_log} and \code{binomial\_coefficient\_log} Functions}

\begin{description}
\item[Deprecated]  Currently two non-conforming functions ending in
  suffix \code{\_log}.
\item[Replacement] Replace \code{multiply\_log(...)} with
  \code{lmultiply(...)}.  
\\[4pt]
Replace \code{binomial\_coefficient\_log(...)} with \code{lchoose(...)}.
\end{description}

\section{User-Defined Function with \code{\_log} Suffix}

\begin{description}
\item[Deprecated] A user-defined function ending in \code{\_log} can
  be used in sampling statements, with
%
\begin{stancode}
y ~ foo(...);
\end{stancode}
%
having the same effect as 
%
\begin{stancode}
target += foo_log(y, ...);
\end{stancode}
\item[Replacement]
Replace the \code{\_log} suffix with \code{\_lpdf} for
density functions or \code{\_lpmf} for mass functions in the
user-defined function.
\end{description}

\section{\code{lkj\_cov} Distribution}

\begin{description}
\item[Deprecated]The distribution \code{lkj\_cov} is deprecated.
\item[Replacement] Replace \code{lkj\_cov\_log(...)} with an
  \code{lkj\_corr} distribution on the correlation matrix and
  independent lognormal distributions on the scales.  That is,
  replace
\begin{stancode}
cov_matrix[K] Sigma;
...
Sigma ~ lkj_cov(mu, tau, eta);
\end{stancode}
  with
\begin{stancode}
corr_matrix[K] Omega;
vector<lower=0>[K] sigma;
...
Omega ~ lkj_corr(eta);
sigma ~ lognormal(mu, tau);
...
cov_matrix[K] Sigma;
Sigma <- quad_form_diag(Omega, sigma);
\end{stancode}
The variable \code{Sigma} may be defined as a local variable in the
model block or as a transformed parameter.  An even more efficient
transform would use Cholesky factors rather than full correlation
matrix types.
\end{description}

\section{\code{if\_else} Function}

\begin{description}
\item[Deprecated]The function \code{if\_else} is deprecated.  This function takes three arguments
\code{a}, \code{b}, and \code{c}, where \code{a} is an \code{int} value and \code{b} and \code{c}
are scalars. It returns \code{b} if \code{a} is non-zero and \code{c} otherwise.
%
\item[Replacement] Use the conditional operator which allows more
  flexiblity in the types of \code{b} and \code{c} and is much more
  efficient in that it only evaluates whichever of \code{b} or
  \code{c} is returned.  See \refsection{conditional-operator} for
  full details of the conditional operator.  Replace
\begin{stancode}
x = if_else(a,b,c);
\end{stancode}
 with
\begin{stancode}
x = a ? b : c;
\end{stancode}
\end{description}

\chapter{Mathematical Functions}\label{math-functions.appendix}

This appendix provides the definition of several mathematical
functions used throughout the manual.

\section{Beta}\label{beta-appendix.section}

The beta function, $\mbox{B}(\alpha,\beta)$, computes the normalizing
constant for the beta distribution, and is defined for $a > 0$ and $b
> 0$ by
%
\[
\mbox{B}(a,b)
\ = \
\int_0^1 u^{a - 1} (1 - u)^{b - 1} \, du
\ = \
\frac{\Gamma(a) \, \Gamma(b)}{\Gamma(a+b)} \, .
\]

\section{Incomplete Beta}\label{inc-beta-appendix.section}

The incomplete beta function, $\mathrm{B}(x; a, b)$, is defined for 
$x \in [0, 1]$ and $a, b \geq 0$ such that $a + b \neq 0$ by
\[
\mathrm{B}(x; \, a, b) 
\ = \
\int_0^x u^{a -  1} \, (1 - u)^{b - 1} \, du,
\]
%
where $\mathrm{B}(a, b)$ is the beta function defined in
\refsection{beta-appendix}.  If $x = 1$, the incomplete beta function
reduces to the beta function, $\mathrm{B}(1; a, b) = \mathrm{B}(a,
b)$.

The regularized incomplete beta function divides the incomplete beta
function by the beta function,
\[
I_x(a, b) \ = \ \frac{\mathrm{B}(x; \, a, b)}{B(a, b)} \, .
\]




\section{Gamma}\label{gamma-appendix.section}

The gamma function, $\Gamma(x)$, is the generalization of the
factorial function to continuous variables, defined so that for
positive integers $n$,
\[
\Gamma(n+1) = n!
\]
%
Generalizing to all positive numbers and non-integer negative numbers,
\[
\Gamma(x) = \int_0^{\infty} u^{x - 1} \exp(-u) \, du.
\]


\section{Digamma}\label{digamma-appendix.section}

The digamma function $\Psi$ is the derivative of the $\log \Gamma$
function,
%
\[
\Psi(u) 
\ = \
\frac{d}{d u} \log \Gamma(u) 
\ = \
\frac{1}{\Gamma(u)} \ \frac{d}{d u} \Gamma(u).
\]
