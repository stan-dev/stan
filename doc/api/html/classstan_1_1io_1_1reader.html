<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Stan: stan::io::reader&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stan
   &#160;<span id="projectnumber">2.7.0</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classstan_1_1io_1_1reader.html">reader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstan_1_1io_1_1reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stan::io::reader&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A stream-based reader for integer, scalar, vector, matrix and array data types, with Jacobian calculations.  
 <a href="classstan_1_1io_1_1reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="reader_8hpp_source.html">reader.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a96a6c8c011e0876210058762dddc2e2a"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a></td></tr>
<tr class="separator:a96a6c8c011e0876210058762dddc2e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf175423e2fcc4e9a4563c128e41dd0"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a></td></tr>
<tr class="separator:a2cf175423e2fcc4e9a4563c128e41dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e8bfb1b6dcbe339afc4018061c6e20"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a></td></tr>
<tr class="separator:ae7e8bfb1b6dcbe339afc4018061c6e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f161f2ef596f356d249afbb0b43ca6"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; <a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a05f161f2ef596f356d249afbb0b43ca6">map_matrix_t</a></td></tr>
<tr class="separator:a05f161f2ef596f356d249afbb0b43ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285611f704d4a3ec0d0e10ff98206d4"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; <a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a1285611f704d4a3ec0d0e10ff98206d4">map_vector_t</a></td></tr>
<tr class="separator:a1285611f704d4a3ec0d0e10ff98206d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71946c44faafcf4669f3cfde52816633"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; <a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a71946c44faafcf4669f3cfde52816633">map_row_vector_t</a></td></tr>
<tr class="separator:a71946c44faafcf4669f3cfde52816633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3ae88d711db3f2469c86131c28191ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa3ae88d711db3f2469c86131c28191ac">reader</a> (std::vector&lt; T &gt; &amp;data_r, std::vector&lt; int &gt; &amp;data_i)</td></tr>
<tr class="memdesc:aa3ae88d711db3f2469c86131c28191ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a variable reader using the specified vectors as the source of scalar and integer values for data.  <a href="#aa3ae88d711db3f2469c86131c28191ac">More...</a><br/></td></tr>
<tr class="separator:aa3ae88d711db3f2469c86131c28191ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679801e4a7936f90c13e9a6498745314"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a679801e4a7936f90c13e9a6498745314">~reader</a> ()</td></tr>
<tr class="memdesc:a679801e4a7936f90c13e9a6498745314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this variable reader.  <a href="#a679801e4a7936f90c13e9a6498745314">More...</a><br/></td></tr>
<tr class="separator:a679801e4a7936f90c13e9a6498745314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581d87c0d6f4fbcc889fcda61d9da129"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a581d87c0d6f4fbcc889fcda61d9da129">available</a> ()</td></tr>
<tr class="memdesc:a581d87c0d6f4fbcc889fcda61d9da129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of scalars remaining to be read.  <a href="#a581d87c0d6f4fbcc889fcda61d9da129">More...</a><br/></td></tr>
<tr class="separator:a581d87c0d6f4fbcc889fcda61d9da129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f82bd5d88795b0012d04b239685858"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a69f82bd5d88795b0012d04b239685858">available_i</a> ()</td></tr>
<tr class="memdesc:a69f82bd5d88795b0012d04b239685858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of integers remaining to be read.  <a href="#a69f82bd5d88795b0012d04b239685858">More...</a><br/></td></tr>
<tr class="separator:a69f82bd5d88795b0012d04b239685858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a2b111d918d34bfebf6bb3b821495f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#af1a2b111d918d34bfebf6bb3b821495f">integer</a> ()</td></tr>
<tr class="memdesc:af1a2b111d918d34bfebf6bb3b821495f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer in the integer sequence.  <a href="#af1a2b111d918d34bfebf6bb3b821495f">More...</a><br/></td></tr>
<tr class="separator:af1a2b111d918d34bfebf6bb3b821495f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd55003bc47a1eade2c75c20d0d13f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aeccd55003bc47a1eade2c75c20d0d13f">integer_constrain</a> ()</td></tr>
<tr class="memdesc:aeccd55003bc47a1eade2c75c20d0d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer in the integer sequence.  <a href="#aeccd55003bc47a1eade2c75c20d0d13f">More...</a><br/></td></tr>
<tr class="separator:aeccd55003bc47a1eade2c75c20d0d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d16a67c77fa38a5da05da6b4eb563f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a41d16a67c77fa38a5da05da6b4eb563f">integer_constrain</a> (T &amp;)</td></tr>
<tr class="memdesc:a41d16a67c77fa38a5da05da6b4eb563f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer in the integer sequence.  <a href="#a41d16a67c77fa38a5da05da6b4eb563f">More...</a><br/></td></tr>
<tr class="separator:a41d16a67c77fa38a5da05da6b4eb563f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804e3de3992c9f6a53c03596369dd1d0"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a804e3de3992c9f6a53c03596369dd1d0">scalar</a> ()</td></tr>
<tr class="memdesc:a804e3de3992c9f6a53c03596369dd1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar in the sequence.  <a href="#a804e3de3992c9f6a53c03596369dd1d0">More...</a><br/></td></tr>
<tr class="separator:a804e3de3992c9f6a53c03596369dd1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1436d19aa2acb5c139f7abccda0245c0"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a1436d19aa2acb5c139f7abccda0245c0">scalar_constrain</a> ()</td></tr>
<tr class="memdesc:a1436d19aa2acb5c139f7abccda0245c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar.  <a href="#a1436d19aa2acb5c139f7abccda0245c0">More...</a><br/></td></tr>
<tr class="separator:a1436d19aa2acb5c139f7abccda0245c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d45ed51c042512f07e2c977894b7b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#adc2d45ed51c042512f07e2c977894b7b">scalar_constrain</a> (T &amp;)</td></tr>
<tr class="memdesc:adc2d45ed51c042512f07e2c977894b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar in the sequence, incrementing the specified reference with the log absolute Jacobian determinant.  <a href="#adc2d45ed51c042512f07e2c977894b7b">More...</a><br/></td></tr>
<tr class="separator:adc2d45ed51c042512f07e2c977894b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a39fbd649e5be85b0f20ac00721c35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a72a39fbd649e5be85b0f20ac00721c35">std_vector</a> (size_t m)</td></tr>
<tr class="memdesc:a72a39fbd649e5be85b0f20ac00721c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard library vector of the specified dimensionality made up of the next scalars.  <a href="#a72a39fbd649e5be85b0f20ac00721c35">More...</a><br/></td></tr>
<tr class="separator:a72a39fbd649e5be85b0f20ac00721c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cbe04c9a1439e20b27c3cf612bd963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ac7cbe04c9a1439e20b27c3cf612bd963">vector</a> (size_t m)</td></tr>
<tr class="memdesc:ac7cbe04c9a1439e20b27c3cf612bd963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of specified dimensionality made up of the next scalars.  <a href="#ac7cbe04c9a1439e20b27c3cf612bd963">More...</a><br/></td></tr>
<tr class="separator:ac7cbe04c9a1439e20b27c3cf612bd963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393939c8de7bd2609b069424244b005a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a393939c8de7bd2609b069424244b005a">vector_constrain</a> (size_t m)</td></tr>
<tr class="memdesc:a393939c8de7bd2609b069424244b005a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of specified dimensionality made up of the next scalars.  <a href="#a393939c8de7bd2609b069424244b005a">More...</a><br/></td></tr>
<tr class="separator:a393939c8de7bd2609b069424244b005a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8c3e697090c981438b94da63c02ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aec8c3e697090c981438b94da63c02ccc">vector_constrain</a> (size_t m, T &amp;)</td></tr>
<tr class="memdesc:aec8c3e697090c981438b94da63c02ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of specified dimensionality made up of the next scalars.  <a href="#aec8c3e697090c981438b94da63c02ccc">More...</a><br/></td></tr>
<tr class="separator:aec8c3e697090c981438b94da63c02ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857c3ed31d34189e5768ef2475024b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a857c3ed31d34189e5768ef2475024b36">row_vector</a> (size_t m)</td></tr>
<tr class="memdesc:a857c3ed31d34189e5768ef2475024b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of specified dimensionality made up of the next scalars.  <a href="#a857c3ed31d34189e5768ef2475024b36">More...</a><br/></td></tr>
<tr class="separator:a857c3ed31d34189e5768ef2475024b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f84052299bcadcd6bdf0273e7a48d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a83f84052299bcadcd6bdf0273e7a48d4">row_vector_constrain</a> (size_t m)</td></tr>
<tr class="memdesc:a83f84052299bcadcd6bdf0273e7a48d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of specified dimensionality made up of the next scalars.  <a href="#a83f84052299bcadcd6bdf0273e7a48d4">More...</a><br/></td></tr>
<tr class="separator:a83f84052299bcadcd6bdf0273e7a48d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2165af289c7ec046db04aec5d369bc9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a2165af289c7ec046db04aec5d369bc9b">row_vector_constrain</a> (size_t m, T &amp;)</td></tr>
<tr class="memdesc:a2165af289c7ec046db04aec5d369bc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of specified dimensionality made up of the next scalars.  <a href="#a2165af289c7ec046db04aec5d369bc9b">More...</a><br/></td></tr>
<tr class="separator:a2165af289c7ec046db04aec5d369bc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2aeccae677df87006d976cbcae9fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#afd2aeccae677df87006d976cbcae9fd2">matrix</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:afd2aeccae677df87006d976cbcae9fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order.  <a href="#afd2aeccae677df87006d976cbcae9fd2">More...</a><br/></td></tr>
<tr class="separator:afd2aeccae677df87006d976cbcae9fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72043393997619c044478ced8a867f69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a72043393997619c044478ced8a867f69">matrix_constrain</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a72043393997619c044478ced8a867f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order.  <a href="#a72043393997619c044478ced8a867f69">More...</a><br/></td></tr>
<tr class="separator:a72043393997619c044478ced8a867f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a9e74ffa53964f23173a5c31e798c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a44a9e74ffa53964f23173a5c31e798c8">matrix_constrain</a> (size_t m, size_t n, T &amp;)</td></tr>
<tr class="memdesc:a44a9e74ffa53964f23173a5c31e798c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order.  <a href="#a44a9e74ffa53964f23173a5c31e798c8">More...</a><br/></td></tr>
<tr class="separator:a44a9e74ffa53964f23173a5c31e798c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1535fc6c26ecedd2aa25989853a09261"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a1535fc6c26ecedd2aa25989853a09261">integer_lb</a> (int lb)</td></tr>
<tr class="memdesc:a1535fc6c26ecedd2aa25989853a09261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is greater than or equal to the specified lower bound.  <a href="#a1535fc6c26ecedd2aa25989853a09261">More...</a><br/></td></tr>
<tr class="separator:a1535fc6c26ecedd2aa25989853a09261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287c3669f5eea0a5b2f22708d26da67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a9287c3669f5eea0a5b2f22708d26da67">integer_lb_constrain</a> (int lb)</td></tr>
<tr class="memdesc:a9287c3669f5eea0a5b2f22708d26da67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is greater than or equal to the specified lower bound.  <a href="#a9287c3669f5eea0a5b2f22708d26da67">More...</a><br/></td></tr>
<tr class="separator:a9287c3669f5eea0a5b2f22708d26da67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786ee459470898a8fbc8a240dec6f269"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a786ee459470898a8fbc8a240dec6f269">integer_lb_constrain</a> (int lb, T &amp;)</td></tr>
<tr class="memdesc:a786ee459470898a8fbc8a240dec6f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is greater than or equal to the specified lower bound.  <a href="#a786ee459470898a8fbc8a240dec6f269">More...</a><br/></td></tr>
<tr class="separator:a786ee459470898a8fbc8a240dec6f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dce1d461bcef2fda9d996fb07bb6782"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a5dce1d461bcef2fda9d996fb07bb6782">integer_ub</a> (int ub)</td></tr>
<tr class="memdesc:a5dce1d461bcef2fda9d996fb07bb6782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#a5dce1d461bcef2fda9d996fb07bb6782">More...</a><br/></td></tr>
<tr class="separator:a5dce1d461bcef2fda9d996fb07bb6782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa492d17e0aeaba5a082fc554d248048e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa492d17e0aeaba5a082fc554d248048e">integer_ub_constrain</a> (int ub)</td></tr>
<tr class="memdesc:aa492d17e0aeaba5a082fc554d248048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#aa492d17e0aeaba5a082fc554d248048e">More...</a><br/></td></tr>
<tr class="separator:aa492d17e0aeaba5a082fc554d248048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23ce5d0b04667272770eb04eff2bfd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ad23ce5d0b04667272770eb04eff2bfd4">integer_ub_constrain</a> (int ub, T &amp;)</td></tr>
<tr class="memdesc:ad23ce5d0b04667272770eb04eff2bfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#ad23ce5d0b04667272770eb04eff2bfd4">More...</a><br/></td></tr>
<tr class="separator:ad23ce5d0b04667272770eb04eff2bfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be53bcf3f435d5c25b07774853afa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#af9be53bcf3f435d5c25b07774853afa3">integer_lub</a> (int lb, int ub)</td></tr>
<tr class="memdesc:af9be53bcf3f435d5c25b07774853afa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#af9be53bcf3f435d5c25b07774853afa3">More...</a><br/></td></tr>
<tr class="separator:af9be53bcf3f435d5c25b07774853afa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73203544d85c8e7f4a6e682edb8db4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa73203544d85c8e7f4a6e682edb8db4f">integer_lub_constrain</a> (int lb, int ub)</td></tr>
<tr class="memdesc:aa73203544d85c8e7f4a6e682edb8db4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#aa73203544d85c8e7f4a6e682edb8db4f">More...</a><br/></td></tr>
<tr class="separator:aa73203544d85c8e7f4a6e682edb8db4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0934519cf50d98a616b4e3a0bc9539fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a0934519cf50d98a616b4e3a0bc9539fc">integer_lub_constrain</a> (int lb, int ub, T &amp;)</td></tr>
<tr class="memdesc:a0934519cf50d98a616b4e3a0bc9539fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next integer, checking that it is less than or equal to the specified upper bound.  <a href="#a0934519cf50d98a616b4e3a0bc9539fc">More...</a><br/></td></tr>
<tr class="separator:a0934519cf50d98a616b4e3a0bc9539fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5c5343597a44d4d2173881c7c68912"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#acf5c5343597a44d4d2173881c7c68912">scalar_pos</a> ()</td></tr>
<tr class="memdesc:acf5c5343597a44d4d2173881c7c68912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is positive.  <a href="#acf5c5343597a44d4d2173881c7c68912">More...</a><br/></td></tr>
<tr class="separator:acf5c5343597a44d4d2173881c7c68912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d5a9c201fb25c44f1bba987e64d387"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a45d5a9c201fb25c44f1bba987e64d387">scalar_pos_constrain</a> ()</td></tr>
<tr class="memdesc:a45d5a9c201fb25c44f1bba987e64d387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, transformed to be positive.  <a href="#a45d5a9c201fb25c44f1bba987e64d387">More...</a><br/></td></tr>
<tr class="separator:a45d5a9c201fb25c44f1bba987e64d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d6bf28bfa13c861ce1afe8cd7d4c1e"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a41d6bf28bfa13c861ce1afe8cd7d4c1e">scalar_pos_constrain</a> (T &amp;lp)</td></tr>
<tr class="memdesc:a41d6bf28bfa13c861ce1afe8cd7d4c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be positive, incrementing the specified reference with the log absolute determinant of the Jacobian.  <a href="#a41d6bf28bfa13c861ce1afe8cd7d4c1e">More...</a><br/></td></tr>
<tr class="separator:a41d6bf28bfa13c861ce1afe8cd7d4c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d5909de270e2f187707c7bdfa1b2ba"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a63d5909de270e2f187707c7bdfa1b2ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a63d5909de270e2f187707c7bdfa1b2ba">scalar_lb</a> (const TL lb)</td></tr>
<tr class="memdesc:a63d5909de270e2f187707c7bdfa1b2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is greater than or equal to the specified lower bound.  <a href="#a63d5909de270e2f187707c7bdfa1b2ba">More...</a><br/></td></tr>
<tr class="separator:a63d5909de270e2f187707c7bdfa1b2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9191795f375a3e3c5e048ca1eb045ba"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:aa9191795f375a3e3c5e048ca1eb045ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa9191795f375a3e3c5e048ca1eb045ba">scalar_lb_constrain</a> (const TL lb)</td></tr>
<tr class="memdesc:aa9191795f375a3e3c5e048ca1eb045ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to have the specified lower bound.  <a href="#aa9191795f375a3e3c5e048ca1eb045ba">More...</a><br/></td></tr>
<tr class="separator:aa9191795f375a3e3c5e048ca1eb045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc8affb3f2c3835965d943c7a7ce83c"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a8fc8affb3f2c3835965d943c7a7ce83c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a8fc8affb3f2c3835965d943c7a7ce83c">scalar_lb_constrain</a> (const TL lb, T &amp;lp)</td></tr>
<tr class="memdesc:a8fc8affb3f2c3835965d943c7a7ce83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to have the specified lower bound, incrementing the specified reference with the log of the absolute Jacobian determinant of the transform.  <a href="#a8fc8affb3f2c3835965d943c7a7ce83c">More...</a><br/></td></tr>
<tr class="separator:a8fc8affb3f2c3835965d943c7a7ce83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e2f8eca996110fb2be2e436d583b62"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:aa5e2f8eca996110fb2be2e436d583b62"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa5e2f8eca996110fb2be2e436d583b62">scalar_ub</a> (TU ub)</td></tr>
<tr class="memdesc:aa5e2f8eca996110fb2be2e436d583b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is less than or equal to the specified upper bound.  <a href="#aa5e2f8eca996110fb2be2e436d583b62">More...</a><br/></td></tr>
<tr class="separator:aa5e2f8eca996110fb2be2e436d583b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b4b63d07615a9d0a7c5de364a43a36"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a21b4b63d07615a9d0a7c5de364a43a36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a21b4b63d07615a9d0a7c5de364a43a36">scalar_ub_constrain</a> (const TU ub)</td></tr>
<tr class="memdesc:a21b4b63d07615a9d0a7c5de364a43a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to have the specified upper bound.  <a href="#a21b4b63d07615a9d0a7c5de364a43a36">More...</a><br/></td></tr>
<tr class="separator:a21b4b63d07615a9d0a7c5de364a43a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afbd36262b7a2f51dec8d2fad471dd"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a48afbd36262b7a2f51dec8d2fad471dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a48afbd36262b7a2f51dec8d2fad471dd">scalar_ub_constrain</a> (const TU ub, T &amp;lp)</td></tr>
<tr class="memdesc:a48afbd36262b7a2f51dec8d2fad471dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to have the specified upper bound, incrementing the specified reference with the log of the absolute Jacobian determinant of the transform.  <a href="#a48afbd36262b7a2f51dec8d2fad471dd">More...</a><br/></td></tr>
<tr class="separator:a48afbd36262b7a2f51dec8d2fad471dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f36e576e51d8e9d72589133d7cf107"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a13f36e576e51d8e9d72589133d7cf107"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a13f36e576e51d8e9d72589133d7cf107">scalar_lub</a> (const TL lb, const TU ub)</td></tr>
<tr class="memdesc:a13f36e576e51d8e9d72589133d7cf107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is between the specified lower and upper bound.  <a href="#a13f36e576e51d8e9d72589133d7cf107">More...</a><br/></td></tr>
<tr class="separator:a13f36e576e51d8e9d72589133d7cf107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12299645ca45f2b765fea6fe14447733"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a12299645ca45f2b765fea6fe14447733"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a12299645ca45f2b765fea6fe14447733">scalar_lub_constrain</a> (const TL lb, const TU ub)</td></tr>
<tr class="memdesc:a12299645ca45f2b765fea6fe14447733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be between the specified lower and upper bounds.  <a href="#a12299645ca45f2b765fea6fe14447733">More...</a><br/></td></tr>
<tr class="separator:a12299645ca45f2b765fea6fe14447733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad821d1abbeefcd04f3350a213276d53e"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:ad821d1abbeefcd04f3350a213276d53e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ad821d1abbeefcd04f3350a213276d53e">scalar_lub_constrain</a> (TL lb, TU ub, T &amp;lp)</td></tr>
<tr class="memdesc:ad821d1abbeefcd04f3350a213276d53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be between the the specified lower and upper bounds.  <a href="#ad821d1abbeefcd04f3350a213276d53e">More...</a><br/></td></tr>
<tr class="separator:ad821d1abbeefcd04f3350a213276d53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57e12e95a36df2d9448f6123e3d2cfa"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ad57e12e95a36df2d9448f6123e3d2cfa">prob</a> ()</td></tr>
<tr class="memdesc:ad57e12e95a36df2d9448f6123e3d2cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is a valid value for a probability, between 0 (inclusive) and 1 (inclusive).  <a href="#ad57e12e95a36df2d9448f6123e3d2cfa">More...</a><br/></td></tr>
<tr class="separator:ad57e12e95a36df2d9448f6123e3d2cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d999e486addc7652b2be90365b89bc4"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a2d999e486addc7652b2be90365b89bc4">prob_constrain</a> ()</td></tr>
<tr class="memdesc:a2d999e486addc7652b2be90365b89bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be a probability between 0 and 1.  <a href="#a2d999e486addc7652b2be90365b89bc4">More...</a><br/></td></tr>
<tr class="separator:a2d999e486addc7652b2be90365b89bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0565ad1ff42fe678bcb51ed748455"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a07a0565ad1ff42fe678bcb51ed748455">prob_constrain</a> (T &amp;lp)</td></tr>
<tr class="memdesc:a07a0565ad1ff42fe678bcb51ed748455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be a probability between 0 and 1, incrementing the specified reference with the log of the absolute Jacobian determinant.  <a href="#a07a0565ad1ff42fe678bcb51ed748455">More...</a><br/></td></tr>
<tr class="separator:a07a0565ad1ff42fe678bcb51ed748455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af409911d7c4b3996291884fbebecfd85"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#af409911d7c4b3996291884fbebecfd85">corr</a> ()</td></tr>
<tr class="memdesc:af409911d7c4b3996291884fbebecfd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar, checking that it is a valid value for a correlation, between -1 (inclusive) and 1 (inclusive).  <a href="#af409911d7c4b3996291884fbebecfd85">More...</a><br/></td></tr>
<tr class="separator:af409911d7c4b3996291884fbebecfd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaafba520a6ad5ae7654e24d46ffbb39"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aeaafba520a6ad5ae7654e24d46ffbb39">corr_constrain</a> ()</td></tr>
<tr class="memdesc:aeaafba520a6ad5ae7654e24d46ffbb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be a correlation between -1 and 1.  <a href="#aeaafba520a6ad5ae7654e24d46ffbb39">More...</a><br/></td></tr>
<tr class="separator:aeaafba520a6ad5ae7654e24d46ffbb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d52f9f5ffec50991cf3224f1caad9c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a83d52f9f5ffec50991cf3224f1caad9c">corr_constrain</a> (T &amp;lp)</td></tr>
<tr class="memdesc:a83d52f9f5ffec50991cf3224f1caad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next scalar transformed to be a (partial) correlation between -1 and 1, incrementing the specified reference with the log of the absolute Jacobian determinant.  <a href="#a83d52f9f5ffec50991cf3224f1caad9c">More...</a><br/></td></tr>
<tr class="separator:a83d52f9f5ffec50991cf3224f1caad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8ebf459013095c8bef590c5e7f2dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a6b8ebf459013095c8bef590c5e7f2dd2">unit_vector</a> (size_t k)</td></tr>
<tr class="memdesc:a6b8ebf459013095c8bef590c5e7f2dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unit_vector of the specified size made up of the next scalars.  <a href="#a6b8ebf459013095c8bef590c5e7f2dd2">More...</a><br/></td></tr>
<tr class="separator:a6b8ebf459013095c8bef590c5e7f2dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028dec5590601889ee7a0d0d0ae1fd72"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a028dec5590601889ee7a0d0d0ae1fd72">unit_vector_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:a028dec5590601889ee7a0d0d0ae1fd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next unit_vector transformed vector of the specified length.  <a href="#a028dec5590601889ee7a0d0d0ae1fd72">More...</a><br/></td></tr>
<tr class="separator:a028dec5590601889ee7a0d0d0ae1fd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c986f3ceee7c402820835ba7bfde62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ac4c986f3ceee7c402820835ba7bfde62">unit_vector_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:ac4c986f3ceee7c402820835ba7bfde62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next unit_vector of the specified size (using one fewer unconstrained scalars), incrementing the specified reference with the log absolute Jacobian determinant.  <a href="#ac4c986f3ceee7c402820835ba7bfde62">More...</a><br/></td></tr>
<tr class="separator:ac4c986f3ceee7c402820835ba7bfde62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b15c1f051764a8a50a08c5880f810bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a9b15c1f051764a8a50a08c5880f810bb">simplex</a> (size_t k)</td></tr>
<tr class="memdesc:a9b15c1f051764a8a50a08c5880f810bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a simplex of the specified size made up of the next scalars.  <a href="#a9b15c1f051764a8a50a08c5880f810bb">More...</a><br/></td></tr>
<tr class="separator:a9b15c1f051764a8a50a08c5880f810bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0ae1e4c49ab2a662de03d9f31dd8df"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#abb0ae1e4c49ab2a662de03d9f31dd8df">simplex_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:abb0ae1e4c49ab2a662de03d9f31dd8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next simplex transformed vector of the specified length.  <a href="#abb0ae1e4c49ab2a662de03d9f31dd8df">More...</a><br/></td></tr>
<tr class="separator:abb0ae1e4c49ab2a662de03d9f31dd8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee8c20266159e7ce8763c8014bf2899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a8ee8c20266159e7ce8763c8014bf2899">simplex_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:a8ee8c20266159e7ce8763c8014bf2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next simplex of the specified size (using one fewer unconstrained scalars), incrementing the specified reference with the log absolute Jacobian determinant.  <a href="#a8ee8c20266159e7ce8763c8014bf2899">More...</a><br/></td></tr>
<tr class="separator:a8ee8c20266159e7ce8763c8014bf2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5597679b7085f74c44ae623ef117410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ae5597679b7085f74c44ae623ef117410">ordered</a> (size_t k)</td></tr>
<tr class="memdesc:ae5597679b7085f74c44ae623ef117410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next vector of specified size containing values in ascending order.  <a href="#ae5597679b7085f74c44ae623ef117410">More...</a><br/></td></tr>
<tr class="separator:ae5597679b7085f74c44ae623ef117410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae371520b9f4d28912092b43c40fdccb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ae371520b9f4d28912092b43c40fdccb3">ordered_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:ae371520b9f4d28912092b43c40fdccb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next ordered vector of the specified length.  <a href="#ae371520b9f4d28912092b43c40fdccb3">More...</a><br/></td></tr>
<tr class="separator:ae371520b9f4d28912092b43c40fdccb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e91154c913c5645c8a4ae474f1a6748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a8e91154c913c5645c8a4ae474f1a6748">ordered_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:a8e91154c913c5645c8a4ae474f1a6748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next ordered vector of the specified size, incrementing the specified reference with the log absolute Jacobian of the determinant.  <a href="#a8e91154c913c5645c8a4ae474f1a6748">More...</a><br/></td></tr>
<tr class="separator:a8e91154c913c5645c8a4ae474f1a6748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f49da1bc5719a4cd6da4b35f488b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ac3f49da1bc5719a4cd6da4b35f488b34">positive_ordered</a> (size_t k)</td></tr>
<tr class="memdesc:ac3f49da1bc5719a4cd6da4b35f488b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next vector of specified size containing positive values in ascending order.  <a href="#ac3f49da1bc5719a4cd6da4b35f488b34">More...</a><br/></td></tr>
<tr class="separator:ac3f49da1bc5719a4cd6da4b35f488b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeee305b5de15af5e1e296a07649dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aedeee305b5de15af5e1e296a07649dc2">positive_ordered_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:aedeee305b5de15af5e1e296a07649dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next positive ordered vector of the specified length.  <a href="#aedeee305b5de15af5e1e296a07649dc2">More...</a><br/></td></tr>
<tr class="separator:aedeee305b5de15af5e1e296a07649dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2794458867712e2e7dd40674b8e2196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ad2794458867712e2e7dd40674b8e2196">positive_ordered_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:ad2794458867712e2e7dd40674b8e2196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next positive_ordered vector of the specified size, incrementing the specified reference with the log absolute Jacobian of the determinant.  <a href="#ad2794458867712e2e7dd40674b8e2196">More...</a><br/></td></tr>
<tr class="separator:ad2794458867712e2e7dd40674b8e2196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9572cd028cf0d073c45ab83ae6f4477e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a9572cd028cf0d073c45ab83ae6f4477e">cholesky_factor</a> (size_t M, size_t N)</td></tr>
<tr class="memdesc:a9572cd028cf0d073c45ab83ae6f4477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor with the specified dimensionality, reading it directly without transforms.  <a href="#a9572cd028cf0d073c45ab83ae6f4477e">More...</a><br/></td></tr>
<tr class="separator:a9572cd028cf0d073c45ab83ae6f4477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6bee8c526c8d114c95646f171413cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a6c6bee8c526c8d114c95646f171413cc">cholesky_factor_constrain</a> (size_t M, size_t N)</td></tr>
<tr class="memdesc:a6c6bee8c526c8d114c95646f171413cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor with the specified dimensionality, reading from an unconstrained vector of the appropriate size.  <a href="#a6c6bee8c526c8d114c95646f171413cc">More...</a><br/></td></tr>
<tr class="separator:a6c6bee8c526c8d114c95646f171413cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f77d0cd4d89f3d06ac62515cfa809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ac49f77d0cd4d89f3d06ac62515cfa809">cholesky_factor_constrain</a> (size_t M, size_t N, T &amp;lp)</td></tr>
<tr class="memdesc:ac49f77d0cd4d89f3d06ac62515cfa809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor with the specified dimensionality, reading from an unconstrained vector of the appropriate size, and increment the log probability reference with the log Jacobian adjustment for the transform.  <a href="#ac49f77d0cd4d89f3d06ac62515cfa809">More...</a><br/></td></tr>
<tr class="separator:ac49f77d0cd4d89f3d06ac62515cfa809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa043f3bdaf0d48c541bfd0764cc00ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa043f3bdaf0d48c541bfd0764cc00ce3">cholesky_corr</a> (size_t K)</td></tr>
<tr class="memdesc:aa043f3bdaf0d48c541bfd0764cc00ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading it directly without transforms.  <a href="#aa043f3bdaf0d48c541bfd0764cc00ce3">More...</a><br/></td></tr>
<tr class="separator:aa043f3bdaf0d48c541bfd0764cc00ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83efca0780b7c6e4fc2edd12a614dae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a83efca0780b7c6e4fc2edd12a614dae4">cholesky_corr_constrain</a> (size_t K)</td></tr>
<tr class="memdesc:a83efca0780b7c6e4fc2edd12a614dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading from an unconstrained vector of the appropriate size.  <a href="#a83efca0780b7c6e4fc2edd12a614dae4">More...</a><br/></td></tr>
<tr class="separator:a83efca0780b7c6e4fc2edd12a614dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bab8aa023517620bdb948827be5e814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a5bab8aa023517620bdb948827be5e814">cholesky_corr_constrain</a> (size_t K, T &amp;lp)</td></tr>
<tr class="memdesc:a5bab8aa023517620bdb948827be5e814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading from an unconstrained vector of the appropriate size, and increment the log probability reference with the log Jacobian adjustment for the transform.  <a href="#a5bab8aa023517620bdb948827be5e814">More...</a><br/></td></tr>
<tr class="separator:a5bab8aa023517620bdb948827be5e814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0b034457a37f2eb7c27cec9b8e600d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a6b0b034457a37f2eb7c27cec9b8e600d">cov_matrix</a> (size_t k)</td></tr>
<tr class="memdesc:a6b0b034457a37f2eb7c27cec9b8e600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next covariance matrix with the specified dimensionality.  <a href="#a6b0b034457a37f2eb7c27cec9b8e600d">More...</a><br/></td></tr>
<tr class="separator:a6b0b034457a37f2eb7c27cec9b8e600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ada631ae87ef2de7978a33299e872e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ab8ada631ae87ef2de7978a33299e872e">cov_matrix_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:ab8ada631ae87ef2de7978a33299e872e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next covariance matrix of the specified dimensionality.  <a href="#ab8ada631ae87ef2de7978a33299e872e">More...</a><br/></td></tr>
<tr class="separator:ab8ada631ae87ef2de7978a33299e872e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea7077509503ff9bf2777430cb70fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a1ea7077509503ff9bf2777430cb70fcf">cov_matrix_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:a1ea7077509503ff9bf2777430cb70fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next covariance matrix of the specified dimensionality, incrementing the specified reference with the log absolute Jacobian determinant.  <a href="#a1ea7077509503ff9bf2777430cb70fcf">More...</a><br/></td></tr>
<tr class="separator:a1ea7077509503ff9bf2777430cb70fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa410515341701109fb937c14b101e20d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa410515341701109fb937c14b101e20d">corr_matrix</a> (size_t k)</td></tr>
<tr class="memdesc:aa410515341701109fb937c14b101e20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next correlation matrix of the specified dimensionality.  <a href="#aa410515341701109fb937c14b101e20d">More...</a><br/></td></tr>
<tr class="separator:aa410515341701109fb937c14b101e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75eb056f8f7b1032865feb97f506e3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a75eb056f8f7b1032865feb97f506e3e6">corr_matrix_constrain</a> (size_t k)</td></tr>
<tr class="memdesc:a75eb056f8f7b1032865feb97f506e3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next correlation matrix of the specified dimensionality.  <a href="#a75eb056f8f7b1032865feb97f506e3e6">More...</a><br/></td></tr>
<tr class="separator:a75eb056f8f7b1032865feb97f506e3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23e0b88e39d354121b66e6823e1cac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ab23e0b88e39d354121b66e6823e1cac9">corr_matrix_constrain</a> (size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:ab23e0b88e39d354121b66e6823e1cac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next correlation matrix of the specified dimensionality, incrementing the specified reference with the log absolute Jacobian determinant.  <a href="#ab23e0b88e39d354121b66e6823e1cac9">More...</a><br/></td></tr>
<tr class="separator:ab23e0b88e39d354121b66e6823e1cac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eeeaea16178783def48d93e92e502e"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:ae6eeeaea16178783def48d93e92e502e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ae6eeeaea16178783def48d93e92e502e">vector_lb</a> (const TL lb, size_t m)</td></tr>
<tr class="separator:ae6eeeaea16178783def48d93e92e502e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edd356b9b6575e74458dfc36fd1079c"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a8edd356b9b6575e74458dfc36fd1079c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a8edd356b9b6575e74458dfc36fd1079c">vector_lb_constrain</a> (const TL lb, size_t m)</td></tr>
<tr class="separator:a8edd356b9b6575e74458dfc36fd1079c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380b2abea05be45eef534178ccddae74"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a380b2abea05be45eef534178ccddae74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a380b2abea05be45eef534178ccddae74">vector_lb_constrain</a> (const TL lb, size_t m, T &amp;lp)</td></tr>
<tr class="separator:a380b2abea05be45eef534178ccddae74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cbfaaef51a6f1537ae86c13403c8fc"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a91cbfaaef51a6f1537ae86c13403c8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a91cbfaaef51a6f1537ae86c13403c8fc">row_vector_lb</a> (const TL lb, size_t m)</td></tr>
<tr class="separator:a91cbfaaef51a6f1537ae86c13403c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a358a28348483347a0c3d18587dcff"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:ac2a358a28348483347a0c3d18587dcff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ac2a358a28348483347a0c3d18587dcff">row_vector_lb_constrain</a> (const TL lb, size_t m)</td></tr>
<tr class="separator:ac2a358a28348483347a0c3d18587dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03477c8e7dec8028b31d7435161a58d1"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a03477c8e7dec8028b31d7435161a58d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a03477c8e7dec8028b31d7435161a58d1">row_vector_lb_constrain</a> (const TL lb, size_t m, T &amp;lp)</td></tr>
<tr class="separator:a03477c8e7dec8028b31d7435161a58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcad89dd91b23010956526b523ed8c95"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:afcad89dd91b23010956526b523ed8c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#afcad89dd91b23010956526b523ed8c95">matrix_lb</a> (const TL lb, size_t m, size_t n)</td></tr>
<tr class="separator:afcad89dd91b23010956526b523ed8c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b98ecf881169d6dd480caa096c0ed8"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a79b98ecf881169d6dd480caa096c0ed8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a79b98ecf881169d6dd480caa096c0ed8">matrix_lb_constrain</a> (const TL lb, size_t m, size_t n)</td></tr>
<tr class="separator:a79b98ecf881169d6dd480caa096c0ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b119826c47b45fa83df1758de07c5ff"><td class="memTemplParams" colspan="2">template&lt;typename TL &gt; </td></tr>
<tr class="memitem:a9b119826c47b45fa83df1758de07c5ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a9b119826c47b45fa83df1758de07c5ff">matrix_lb_constrain</a> (const TL lb, size_t m, size_t n, T &amp;lp)</td></tr>
<tr class="separator:a9b119826c47b45fa83df1758de07c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d1322b79079e9227ae225a480807db"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a35d1322b79079e9227ae225a480807db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a35d1322b79079e9227ae225a480807db">vector_ub</a> (const TU ub, size_t m)</td></tr>
<tr class="separator:a35d1322b79079e9227ae225a480807db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c24c79245cdcdc447f1d70ab16f67"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a5f5c24c79245cdcdc447f1d70ab16f67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a5f5c24c79245cdcdc447f1d70ab16f67">vector_ub_constrain</a> (const TU ub, size_t m)</td></tr>
<tr class="separator:a5f5c24c79245cdcdc447f1d70ab16f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c62e6ad093def5f59767807a3c46b74"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a7c62e6ad093def5f59767807a3c46b74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a7c62e6ad093def5f59767807a3c46b74">vector_ub_constrain</a> (const TU ub, size_t m, T &amp;lp)</td></tr>
<tr class="separator:a7c62e6ad093def5f59767807a3c46b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2430e335d19e695f50494130e9a183"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a7e2430e335d19e695f50494130e9a183"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a7e2430e335d19e695f50494130e9a183">row_vector_ub</a> (const TU ub, size_t m)</td></tr>
<tr class="separator:a7e2430e335d19e695f50494130e9a183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956b2417c03f1f4645377fc06e1eee94"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a956b2417c03f1f4645377fc06e1eee94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a956b2417c03f1f4645377fc06e1eee94">row_vector_ub_constrain</a> (const TU ub, size_t m)</td></tr>
<tr class="separator:a956b2417c03f1f4645377fc06e1eee94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66650f9f00be4acabf92acfca8c53dbc"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a66650f9f00be4acabf92acfca8c53dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a66650f9f00be4acabf92acfca8c53dbc">row_vector_ub_constrain</a> (const TU ub, size_t m, T &amp;lp)</td></tr>
<tr class="separator:a66650f9f00be4acabf92acfca8c53dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280b0c933f7dae06f472e56432b45489"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:a280b0c933f7dae06f472e56432b45489"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a280b0c933f7dae06f472e56432b45489">matrix_ub</a> (const TU ub, size_t m, size_t n)</td></tr>
<tr class="separator:a280b0c933f7dae06f472e56432b45489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70a11c24ac7cfba146d0864a05dcf9a"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:af70a11c24ac7cfba146d0864a05dcf9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#af70a11c24ac7cfba146d0864a05dcf9a">matrix_ub_constrain</a> (const TU ub, size_t m, size_t n)</td></tr>
<tr class="separator:af70a11c24ac7cfba146d0864a05dcf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace55576f9257795f986494e343c11978"><td class="memTemplParams" colspan="2">template&lt;typename TU &gt; </td></tr>
<tr class="memitem:ace55576f9257795f986494e343c11978"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ace55576f9257795f986494e343c11978">matrix_ub_constrain</a> (const TU ub, size_t m, size_t n, T &amp;lp)</td></tr>
<tr class="separator:ace55576f9257795f986494e343c11978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa86e4338c499595998dd4dc0b58c6d"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:acfa86e4338c499595998dd4dc0b58c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#acfa86e4338c499595998dd4dc0b58c6d">vector_lub</a> (const TL lb, const TU ub, size_t m)</td></tr>
<tr class="separator:acfa86e4338c499595998dd4dc0b58c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb51076e214b1cfee60b70260186c8"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:aa0eb51076e214b1cfee60b70260186c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aa0eb51076e214b1cfee60b70260186c8">vector_lub_constrain</a> (const TL lb, const TU ub, size_t m)</td></tr>
<tr class="separator:aa0eb51076e214b1cfee60b70260186c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0780b890a223ecc7840732bda385e5"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a6f0780b890a223ecc7840732bda385e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a6f0780b890a223ecc7840732bda385e5">vector_lub_constrain</a> (const TL lb, const TU ub, size_t m, T &amp;lp)</td></tr>
<tr class="separator:a6f0780b890a223ecc7840732bda385e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb4db5f423c38abdf0e3cb8f9d9188b"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a4cb4db5f423c38abdf0e3cb8f9d9188b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a4cb4db5f423c38abdf0e3cb8f9d9188b">row_vector_lub</a> (const TL lb, const TU ub, size_t m)</td></tr>
<tr class="separator:a4cb4db5f423c38abdf0e3cb8f9d9188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3a163e402812f41d271adcf974e455"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:aaa3a163e402812f41d271adcf974e455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#aaa3a163e402812f41d271adcf974e455">row_vector_lub_constrain</a> (const TL lb, const TU ub, size_t m)</td></tr>
<tr class="separator:aaa3a163e402812f41d271adcf974e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d1b3316dd321fdf4965d8843920800"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:ab1d1b3316dd321fdf4965d8843920800"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#ab1d1b3316dd321fdf4965d8843920800">row_vector_lub_constrain</a> (const TL lb, const TU ub, size_t m, T &amp;lp)</td></tr>
<tr class="separator:ab1d1b3316dd321fdf4965d8843920800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13209c64b39d9c7515fb561ec788a516"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a13209c64b39d9c7515fb561ec788a516"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a13209c64b39d9c7515fb561ec788a516">matrix_lub</a> (const TL lb, const TU ub, size_t m, size_t n)</td></tr>
<tr class="separator:a13209c64b39d9c7515fb561ec788a516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9007b1739c9738d88347f499e9a39021"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a9007b1739c9738d88347f499e9a39021"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a9007b1739c9738d88347f499e9a39021">matrix_lub_constrain</a> (const TL lb, const TU ub, size_t m, size_t n)</td></tr>
<tr class="separator:a9007b1739c9738d88347f499e9a39021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8a944a6d7ff2ea53cf7a3e78843306"><td class="memTemplParams" colspan="2">template&lt;typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a7b8a944a6d7ff2ea53cf7a3e78843306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1io_1_1reader.html#a7b8a944a6d7ff2ea53cf7a3e78843306">matrix_lub_constrain</a> (const TL lb, const TU ub, size_t m, size_t n, T &amp;lp)</td></tr>
<tr class="separator:a7b8a944a6d7ff2ea53cf7a3e78843306"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class stan::io::reader&lt; T &gt;</h3>

<p>A stream-based reader for integer, scalar, vector, matrix and array data types, with Jacobian calculations. </p>
<p>The template parameter <code>T</code> represents the type of scalars and the values in vectors and matrices. The only requirement on the template type <code>T</code> is that a double can be copied into it, as in</p>
<p><code>T t = 0.0;</code></p>
<p>This includes <code>double</code> itself and the reverse-mode algorithmic differentiation class <code>stan::math::var</code>.</p>
<p>For transformed values, the scalar type parameter <code>T</code> must support the transforming operations, such as <code>exp(x)</code> for positive-bounded variables. It must also support equality and inequality tests with <code>double</code> values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Basic scalar type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00058">58</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a05f161f2ef596f356d249afbb0b43ca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;<a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a>&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#a05f161f2ef596f356d249afbb0b43ca6">map_matrix_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00088">88</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71946c44faafcf4669f3cfde52816633"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;<a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a>&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#a71946c44faafcf4669f3cfde52816633">map_row_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00090">90</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1285611f704d4a3ec0d0e10ff98206d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;<a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a>&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#a1285611f704d4a3ec0d0e10ff98206d4">map_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00089">89</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96a6c8c011e0876210058762dddc2e2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00084">84</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7e8bfb1b6dcbe339afc4018061c6e20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00086">86</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf175423e2fcc4e9a4563c128e41dd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00085">85</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa3ae88d711db3f2469c86131c28191ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::<a class="el" href="classstan_1_1io_1_1reader.html">reader</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a variable reader using the specified vectors as the source of scalar and integer values for data. </p>
<p>This class holds a reference to the specified data vectors.</p>
<p>Attempting to read beyond the end of the data or integer value sequences raises a runtime exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_r</td><td>Sequence of scalar values. </td></tr>
    <tr><td class="paramname">data_i</td><td>Sequence of integer values. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00104">104</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a679801e4a7936f90c13e9a6498745314"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::~<a class="el" href="classstan_1_1io_1_1reader.html">reader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy this variable reader. </p>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00115">115</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a581d87c0d6f4fbcc889fcda61d9da129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of scalars remaining to be read. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of scalars left to read. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00122">122</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69f82bd5d88795b0012d04b239685858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::available_i </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of integers remaining to be read. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of integers left to read. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00131">131</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa043f3bdaf0d48c541bfd0764cc00ce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_corr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading it directly without transforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>Rows and columns of Cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor for a correlation matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor for a correlation matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01038">1038</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83efca0780b7c6e4fc2edd12a614dae4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_corr_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading from an unconstrained vector of the appropriate size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>Rows and columns of Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor for a correlation matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor for a correlation matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01056">1056</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bab8aa023517620bdb948827be5e814"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_corr_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor for a correlation matrix with the specified dimensionality, reading from an unconstrained vector of the appropriate size, and increment the log probability reference with the log Jacobian adjustment for the transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>Rows and columns of Cholesky factor </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor for a correlation matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor for a correlation matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01074">1074</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9572cd028cf0d073c45ab83ae6f4477e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor with the specified dimensionality, reading it directly without transforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Rows of Cholesky factor </td></tr>
    <tr><td class="paramname">N</td><td>Columns of Cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00985">985</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c6bee8c526c8d114c95646f171413cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_factor_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor with the specified dimensionality, reading from an unconstrained vector of the appropriate size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Rows of Cholesky factor </td></tr>
    <tr><td class="paramname">N</td><td>Columns of Cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01003">1003</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac49f77d0cd4d89f3d06ac62515cfa809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cholesky_factor_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next Cholesky factor with the specified dimensionality, reading from an unconstrained vector of the appropriate size, and increment the log probability reference with the log Jacobian adjustment for the transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">M</td><td>Rows of Cholesky factor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>Columns of Cholesky factor </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lp</td><td>log probability </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next Cholesky factor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the matrix is not a valid Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01021">1021</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af409911d7c4b3996291884fbebecfd85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is a valid value for a correlation, between -1 (inclusive) and 1 (inclusive). </p>
<p>See <code>stan::math::check_bounded(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Next correlation value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the value is not valid for a correlation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00754">754</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeaafba520a6ad5ae7654e24d46ffbb39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr_constrain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be a correlation between -1 and 1. </p>
<p>See <code>stan::math::corr_constrain(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to a correlation. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00769">769</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83d52f9f5ffec50991cf3224f1caad9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr_constrain </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be a (partial) correlation between -1 and 1, incrementing the specified reference with the log of the absolute Jacobian determinant. </p>
<p>See <code>stan::math::corr_constrain(T,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>The reference to the variable holding the log probability to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to a correlation. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00784">784</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa410515341701109fb937c14b101e20d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next correlation matrix of the specified dimensionality. </p>
<p>See <code>stan::math::check_corr_matrix(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of correlation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next correlation matrix of the specified dimensionality. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the matrix is not a correlation matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01138">1138</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75eb056f8f7b1032865feb97f506e3e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next correlation matrix of the specified dimensionality. </p>
<p>See <code>stan::math::corr_matrix_constrain(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of correlation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next correlation matrix of the specified dimensionality. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01153">1153</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab23e0b88e39d354121b66e6823e1cac9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::corr_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next correlation matrix of the specified dimensionality, incrementing the specified reference with the log absolute Jacobian determinant. </p>
<p>See <code>stan::math::corr_matrix_constrain(Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of the (square) correlation matrix. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next correlation matrix of the specified dimensionality. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01168">1168</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b0b034457a37f2eb7c27cec9b8e600d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cov_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next covariance matrix with the specified dimensionality. </p>
<p>See <code>stan::math::check_cov_matrix(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next covariance matrix of the specified dimensionality. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the matrix is not a valid covariance matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01092">1092</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ada631ae87ef2de7978a33299e872e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cov_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next covariance matrix of the specified dimensionality. </p>
<p>See <code>stan::math::cov_matrix_constrain(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next covariance matrix of the specified dimensionality. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01107">1107</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ea7077509503ff9bf2777430cb70fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::cov_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next covariance matrix of the specified dimensionality, incrementing the specified reference with the log absolute Jacobian determinant. </p>
<p>See <code>stan::math::cov_matrix_constrain(Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Dimensionality of the (square) covariance matrix. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next covariance matrix of the specified dimensionality. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01123">1123</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1a2b111d918d34bfebf6bb3b821495f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer in the integer sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>Next integer value. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00140">140</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeccd55003bc47a1eade2c75c20d0d13f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_constrain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer in the integer sequence. </p>
<p>This form is a convenience method to make compiling easier; its behavior is the same as <code>int()</code></p>
<dl class="section return"><dt>Returns</dt><dd>Next integer value. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00154">154</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41d16a67c77fa38a5da05da6b4eb563f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_constrain </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer in the integer sequence. </p>
<p>This form is a convenience method to make compiling easier; its behavior is the same as <code><a class="el" href="classstan_1_1io_1_1reader.html#af1a2b111d918d34bfebf6bb3b821495f" title="Return the next integer in the integer sequence. ">integer()</a></code></p>
<dl class="section return"><dt>Returns</dt><dd>Next integer value. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00165">165</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1535fc6c26ecedd2aa25989853a09261"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lb </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is greater than or equal to the specified lower bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not greater than or equal to the lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00362">362</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9287c3669f5eea0a5b2f22708d26da67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is greater than or equal to the specified lower bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not greater than or equal to the lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00378">378</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a786ee459470898a8fbc8a240dec6f269"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is greater than or equal to the specified lower bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. lp Log probability (ignored because no Jacobian) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not greater than or equal to the lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00391">391</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9be53bcf3f435d5c25b07774853afa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lub </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<p>Even if the upper bounds and lower bounds are not consistent, the next integer value will be consumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00450">450</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa73203544d85c8e7f4a6e682edb8db4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00474">474</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0934519cf50d98a616b4e3a0bc9539fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. lp Log probability (ignored because no Jacobian) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00488">488</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dce1d461bcef2fda9d996fb07bb6782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_ub </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00405">405</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa492d17e0aeaba5a082fc554d248048e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00421">421</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad23ce5d0b04667272770eb04eff2bfd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::integer_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next integer, checking that it is less than or equal to the specified upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound. lp Log probability (ignored because no Jacobian) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next integer read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the next integer read is not less than or equal to the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00434">434</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd2aeccae677df87006d976cbcae9fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order. </p>
<p>Row-major reading means that if a matrix of <code>m=2</code> rows and <code>n=3</code> columns is reada and the next scalar values are <code>1,2,3,4,5,6</code>, the result is</p>
<pre>
a = 1 4
    2 5
    3 6</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen::Matrix made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00315">315</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72043393997619c044478ced8a867f69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order. </p>
<p>The constraint is a no-op. See <code>matrix(size_t, size_t)</code> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00330">330</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44a9e74ffa53964f23173a5c31e798c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major order. </p>
<p>The constraint is a no-op, hence the log probability is not incremented. See <code><a class="el" href="classstan_1_1io_1_1reader.html#afd2aeccae677df87006d976cbcae9fd2" title="Return a matrix of the specified dimensionality made up of the next scalars arranged in column-major ...">matrix(size_t, size_t)</a></code> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Number of columns. lp Log probability to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00347">347</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcad89dd91b23010956526b523ed8c95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lb </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01223">1223</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79b98ecf881169d6dd480caa096c0ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01232">1232</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b119826c47b45fa83df1758de07c5ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01242">1242</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13209c64b39d9c7515fb561ec788a516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lub </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01379">1379</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9007b1739c9738d88347f499e9a39021"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01389">1389</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b8a944a6d7ff2ea53cf7a3e78843306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01399">1399</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a280b0c933f7dae06f472e56432b45489"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_ub </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01300">1300</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af70a11c24ac7cfba146d0864a05dcf9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01309">1309</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace55576f9257795f986494e343c11978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a96a6c8c011e0876210058762dddc2e2a">matrix_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::matrix_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01319">1319</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5597679b7085f74c44ae623ef117410"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::ordered </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next vector of specified size containing values in ascending order. </p>
<p>See <code>stan::math::check_ordered(T)</code> for behavior on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of returned vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of positive values in ascending order. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00894">894</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae371520b9f4d28912092b43c40fdccb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next ordered vector of the specified length. </p>
<p>See <code>stan::math::ordered_constrain(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Length of returned vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next ordered vector of the specified length. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00909">909</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e91154c913c5645c8a4ae474f1a6748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next ordered vector of the specified size, incrementing the specified reference with the log absolute Jacobian of the determinant. </p>
<p>See <code>stan::math::ordered_constrain(Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of vector. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next ordered vector of the specified size. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00924">924</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3f49da1bc5719a4cd6da4b35f488b34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::positive_ordered </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next vector of specified size containing positive values in ascending order. </p>
<p>See <code>stan::math::check_positive_ordered(T)</code> for behavior on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of returned vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of positive values in ascending order. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00938">938</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedeee305b5de15af5e1e296a07649dc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::positive_ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next positive ordered vector of the specified length. </p>
<p>See <code>stan::math::positive_ordered_constrain(Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Length of returned vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next positive_ordered vector of the specified length. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00954">954</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2794458867712e2e7dd40674b8e2196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::positive_ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next positive_ordered vector of the specified size, incrementing the specified reference with the log absolute Jacobian of the determinant. </p>
<p>See <code>stan::math::positive_ordered_constrain(Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of vector. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next positive_ordered vector of the specified size. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00969">969</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad57e12e95a36df2d9448f6123e3d2cfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::prob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is a valid value for a probability, between 0 (inclusive) and 1 (inclusive). </p>
<p>See <code>stan::math::check_bounded(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Next probability value. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00707">707</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d999e486addc7652b2be90365b89bc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::prob_constrain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be a probability between 0 and 1. </p>
<p>See <code>stan::math::prob_constrain(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to a probability. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00722">722</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07a0565ad1ff42fe678bcb51ed748455"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::prob_constrain </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be a probability between 0 and 1, incrementing the specified reference with the log of the absolute Jacobian determinant. </p>
<p>See <code>stan::math::prob_constrain(T)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>Reference to log probability variable to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to a probability. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00736">736</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a857c3ed31d34189e5768ef2475024b36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a row vector of specified dimensionality made up of the next scalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00267">267</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83f84052299bcadcd6bdf0273e7a48d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a row vector of specified dimensionality made up of the next scalars. </p>
<p>The constraint is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00279">279</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2165af289c7ec046db04aec5d369bc9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a row vector of specified dimensionality made up of the next scalars. </p>
<p>The constraint is a no-op, so the log probability is not incremented.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. lp Log probability to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00293">293</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91cbfaaef51a6f1537ae86c13403c8fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lb </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01198">1198</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2a358a28348483347a0c3d18587dcff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01206">1206</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03477c8e7dec8028b31d7435161a58d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01215">1215</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb4db5f423c38abdf0e3cb8f9d9188b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lub </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01354">1354</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa3a163e402812f41d271adcf974e455"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01362">1362</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1d1b3316dd321fdf4965d8843920800"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01371">1371</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e2430e335d19e695f50494130e9a183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_ub </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01275">1275</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a956b2417c03f1f4645377fc06e1eee94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01283">1283</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66650f9f00be4acabf92acfca8c53dbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#ae7e8bfb1b6dcbe339afc4018061c6e20">row_vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::row_vector_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01292">1292</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a804e3de3992c9f6a53c03596369dd1d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar in the sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>Next scalar value. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00176">176</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1436d19aa2acb5c139f7abccda0245c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_constrain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar. </p>
<p>For arbitrary scalars, constraint is a no-op.</p>
<dl class="section return"><dt>Returns</dt><dd>Next scalar. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00188">188</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc2d45ed51c042512f07e2c977894b7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_constrain </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar in the sequence, incrementing the specified reference with the log absolute Jacobian determinant. </p>
<p>With no transformation, the Jacobian increment is a no-op.</p>
<p>See <code><a class="el" href="classstan_1_1io_1_1reader.html#a1436d19aa2acb5c139f7abccda0245c0" title="Return the next scalar. ">scalar_constrain()</a></code>.</p>
<p>log_prob Reference to log probability variable to increment. </p>
<dl class="section return"><dt>Returns</dt><dd>Next scalar. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00203">203</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63d5909de270e2f187707c7bdfa1b2ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lb </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is greater than or equal to the specified lower bound. </p>
<p>See <code>stan::math::check_greater_or_equal(T,double)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the scalar is less than the specified lower bound </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00548">548</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9191795f375a3e3c5e048ca1eb045ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to have the specified lower bound. </p>
<p>See <code>stan::math::lb_constrain(T,double)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound on values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar transformed to have the specified lower bound. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00567">567</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc8affb3f2c3835965d943c7a7ce83c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to have the specified lower bound, incrementing the specified reference with the log of the absolute Jacobian determinant of the transform. </p>
<p>See <code>stan::math::lb_constrain(T,double,T&amp;)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound on result. </td></tr>
    <tr><td class="paramname">lp</td><td>Reference to log probability variable to increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00583">583</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13f36e576e51d8e9d72589133d7cf107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lub </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is between the specified lower and upper bound. </p>
<p>See <code>stan::math::check_bounded(T, double, double)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the scalar is not between the specified lower and upper bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00656">656</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12299645ca45f2b765fea6fe14447733"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be between the specified lower and upper bounds. </p>
<p>See <code>stan::math::lub_constrain(T, double, double)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar transformed to fall between the specified bounds. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00677">677</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad821d1abbeefcd04f3350a213276d53e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be between the the specified lower and upper bounds. </p>
<p>See <code>stan::math::lub_constrain(T, double, double, T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">lp</td><td>Reference to log probability variable to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00695">695</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf5c5343597a44d4d2173881c7c68912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is positive. </p>
<p>See <code>stan::math::check_positive(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Next positive scalar. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if x is not positive </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00503">503</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45d5a9c201fb25c44f1bba987e64d387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_pos_constrain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, transformed to be positive. </p>
<p>See <code>stan::math::positive_constrain(T)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to be positive. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00517">517</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41d6bf28bfa13c861ce1afe8cd7d4c1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_pos_constrain </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to be positive, incrementing the specified reference with the log absolute determinant of the Jacobian. </p>
<p>See <code>stan::math::positive_constrain(T,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>Reference to log probability variable to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next scalar transformed to be positive. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00531">531</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5e2f8eca996110fb2be2e436d583b62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_ub </td>
          <td>(</td>
          <td class="paramtype">TU&#160;</td>
          <td class="paramname"><em>ub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar, checking that it is less than or equal to the specified upper bound. </p>
<p>See <code>stan::math::check_less_or_equal(T,double)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the scalar is greater than the specified upper bound </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00602">602</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21b4b63d07615a9d0a7c5de364a43a36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to have the specified upper bound. </p>
<p>See <code>stan::math::ub_constrain(T,double)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound on values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next scalar transformed to have the specified upper bound. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00621">621</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48afbd36262b7a2f51dec8d2fad471dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::scalar_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next scalar transformed to have the specified upper bound, incrementing the specified reference with the log of the absolute Jacobian determinant of the transform. </p>
<p>See <code>stan::math::ub_constrain(T,double,T&amp;)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ub</td><td>Upper bound on result. </td></tr>
    <tr><td class="paramname">lp</td><td>Reference to log probability variable to increment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00637">637</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b15c1f051764a8a50a08c5880f810bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a simplex of the specified size made up of the next scalars. </p>
<p>See <code>stan::math::check_simplex</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of returned simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simplex read from the specified size number of scalars. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the k values is not a simplex. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00846">846</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb0ae1e4c49ab2a662de03d9f31dd8df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::simplex_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next simplex transformed vector of the specified length. </p>
<p>This operation consumes one less than the specified length number of scalars.</p>
<p>See <code>stan::math::simplex_constrain(Eigen::Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of dimensions in resulting simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simplex derived from next <code>k-1</code> scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00864">864</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ee8c20266159e7ce8763c8014bf2899"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::simplex_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next simplex of the specified size (using one fewer unconstrained scalars), incrementing the specified reference with the log absolute Jacobian determinant. </p>
<p>See <code>stan::math::simplex_constrain(Eigen::Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of simplex. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability to increment with log absolute Jacobian determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next simplex of the specified size. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00880">880</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72a39fbd649e5be85b0f20ac00721c35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::std_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a standard library vector of the specified dimensionality made up of the next scalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00215">215</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b8ebf459013095c8bef590c5e7f2dd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::unit_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unit_vector of the specified size made up of the next scalars. </p>
<p>See <code>stan::math::check_unit_vector</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of returned unit_vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit_vector read from the specified size number of scalars. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the k values is not a unit_vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00798">798</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a028dec5590601889ee7a0d0d0ae1fd72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::unit_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next unit_vector transformed vector of the specified length. </p>
<p>This operation consumes one less than the specified length number of scalars.</p>
<p>See <code>stan::math::unit_vector_constrain(Eigen::Matrix)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of dimensions in resulting unit_vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unit_vector derived from next <code>k-1</code> scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00816">816</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4c986f3ceee7c402820835ba7bfde62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::unit_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next unit_vector of the specified size (using one fewer unconstrained scalars), incrementing the specified reference with the log absolute Jacobian determinant. </p>
<p>See <code>stan::math::unit_vector_constrain(Eigen::Matrix,T&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Size of unit_vector. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability to increment with log absolute Jacobian determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next unit_vector of the specified size. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00832">832</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7cbe04c9a1439e20b27c3cf612bd963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of specified dimensionality made up of the next scalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00230">230</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a393939c8de7bd2609b069424244b005a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of specified dimensionality made up of the next scalars. </p>
<p>The constraint is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00241">241</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec8c3e697090c981438b94da63c02ccc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_constrain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of specified dimensionality made up of the next scalars. </p>
<p>The constraint and hence Jacobian are no-ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of rows in the vector to read. lp Log probability to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column vector made up of the next scalars. </dd></dl>

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l00253">253</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6eeeaea16178783def48d93e92e502e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lb </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01174">1174</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8edd356b9b6575e74458dfc36fd1079c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01182">1182</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a380b2abea05be45eef534178ccddae74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01190">1190</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfa86e4338c499595998dd4dc0b58c6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lub </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01328">1328</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0eb51076e214b1cfee60b70260186c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01337">1337</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f0780b890a223ecc7840732bda385e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01346">1346</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35d1322b79079e9227ae225a480807db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_ub </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01251">1251</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f5c24c79245cdcdc447f1d70ab16f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01259">1259</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c62e6ad093def5f59767807a3c46b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1io_1_1reader.html#a2cf175423e2fcc4e9a4563c128e41dd0">vector_t</a> <a class="el" href="classstan_1_1io_1_1reader.html">stan::io::reader</a>&lt; T &gt;::vector_ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reader_8hpp_source.html#l01267">1267</a> of file <a class="el" href="reader_8hpp_source.html">reader.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/stan/io/<a class="el" href="reader_8hpp_source.html">reader.hpp</a></li>
</ul>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2015,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
